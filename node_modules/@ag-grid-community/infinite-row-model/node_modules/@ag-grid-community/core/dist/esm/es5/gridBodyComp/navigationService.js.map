{"version":3,"sources":["../../../src/ts/gridBodyComp/navigationService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,QAAQ,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AAS9E,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAC/C,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,kBAAkB,CAAC;AACnD,OAAO,EAAE,IAAI,EAAE,MAAM,gBAAgB,CAAC;AACtC,OAAO,EAAE,OAAO,EAAE,MAAM,sBAAsB,CAAC;AAG/C,OAAO,EAAE,QAAQ,EAAE,MAAM,4BAA4B,CAAC;AACtD,OAAO,EAAE,OAAO,EAAE,MAAM,0BAA0B,CAAC;AACnD,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,mBAAmB,CAAC;AACrD,OAAO,EAAE,SAAS,EAAE,MAAM,wBAAwB,CAAC;AAQnD,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AAkBtC;IAAuC,qCAAQ;IAmB3C;QAAA,YACI,iBAAO,SAGV;QAFG,KAAI,CAAC,UAAU,GAAG,QAAQ,CAAC,KAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;QACjD,KAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC,KAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;;IACjD,CAAC;IAGO,yCAAa,GAArB;QADA,iBAKC;QAHG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,UAAA,CAAC;YACzB,KAAI,CAAC,WAAW,GAAG,CAAC,CAAC,YAAY,CAAC;QACtC,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,kDAAsB,GAA7B,UAA8B,KAAoB;QAC9C,IAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC;QACtB,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;QACzB,IAAM,IAAI,GAAG,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC;QAC5C,IAAM,6BAA6B,GAAG,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,KAAK,CAAC,QAAQ,CAAC;QAE5E,IAAM,WAAW,GAAwB,IAAI,CAAC,iBAAiB,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC;QAC/F,IAAI,CAAC,WAAW,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEnC,IAAI,SAAS,GAAG,KAAK,CAAC;QAEtB,QAAQ,GAAG,EAAE;YACT,KAAK,OAAO,CAAC,SAAS,CAAC;YACvB,KAAK,OAAO,CAAC,QAAQ;gBACjB,sDAAsD;gBACtD,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACf,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;oBACzB,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,OAAO,CAAC,IAAI,CAAC;YAClB,KAAK,OAAO,CAAC,KAAK,CAAC;YACnB,KAAK,OAAO,CAAC,EAAE,CAAC;YAChB,KAAK,OAAO,CAAC,IAAI;gBACb,wDAAwD;gBACxD,yCAAyC;gBACzC,IAAI,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC,6BAA6B,EAAE;oBAChD,IAAI,CAAC,qBAAqB,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;oBAC7C,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,OAAO,CAAC,SAAS;gBAClB,+DAA+D;gBAC/D,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACf,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;oBAC7B,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;YACV,KAAK,OAAO,CAAC,OAAO;gBAChB,+DAA+D;gBAC/D,IAAI,CAAC,IAAI,IAAI,CAAC,GAAG,EAAE;oBACf,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;oBAC3B,SAAS,GAAG,IAAI,CAAC;iBACpB;gBACD,MAAM;SACb;QAED,IAAI,SAAS,EAAE;YACX,KAAK,CAAC,cAAc,EAAE,CAAC;SAC1B;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAEO,sCAAU,GAAlB,UAAmB,cAA8B;QACrC,IAAA,wCAAW,EAAE,sCAAU,EAAE,0CAAY,EAAE,sCAAU,EAAE,wCAAW,CAAoB;QAE1F,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,EAAE;YAClD,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC;SACzE;QAED,IAAI,MAAM,CAAC,WAAW,CAAC,EAAE;YACrB,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;SACnF;QAED,4DAA4D;QAC5D,IAAI,CAAC,qBAAqB,CAAC,cAAc,EAAE,CAAC;QAE5C,uGAAuG;QACvG,eAAe;QACf,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAEtE,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAM,YAAY,GAAiB,EAAE,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,EAAE,MAAM,EAAE,WAAW,EAAE,CAAC;YAClG,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;SAClD;IACL,CAAC;IAEO,sCAAU,GAAlB,UAAmB,QAAsB;QACrC,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,CAAC;QACxD,IAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,EAAE,CAAC;QAC3E,IAAM,eAAe,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QAEjD,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAEhE,IAAM,sBAAsB,GAAG,cAAc,CAAC,GAAG,GAAG,eAAe,CAAC;QACpE,IAAM,oBAAoB,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,sBAAsB,GAAG,iBAAiB,CAAC,CAAC;QAEjH,IAAI,IAAI,CAAC,WAAW,CAAC,qBAAqB,EAAE,EAAE;YAC1C,IAAI,CAAC,gCAAgC,CAAC,QAAQ,EAAE,oBAAoB,CAAC,CAAC;SACzE;aAAM;YACH,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,oBAAoB,CAAC,CAAC;SAC3D;IACL,CAAC;IAEO,oCAAQ,GAAhB,UAAiB,QAAsB;QACnC,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,CAAC;QACxD,IAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,EAAE,CAAC;QAE3E,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAEhE,IAAM,mBAAmB,GAAG,cAAc,CAAC,GAAG,CAAC;QAC/C,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,mBAAmB,GAAG,iBAAiB,CAAC,CAAC;QAE3G,IAAI,IAAI,CAAC,WAAW,CAAC,qBAAqB,EAAE,EAAE;YAC1C,IAAI,CAAC,gCAAgC,CAAC,QAAQ,EAAE,iBAAiB,EAAE,IAAI,CAAC,CAAC;SAC5E;aAAM;YACH,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,iBAAiB,EAAE,IAAI,CAAC,CAAC;SAC9D;IACL,CAAC;IAEO,8CAAkB,GAA1B,UAA2B,QAAsB,EAAE,WAAmB,EAAE,EAAmB;QAAnB,mBAAA,EAAA,UAAmB;;QACvF,IAAM,eAAe,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACjD,IAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;QACxD,IAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QACtD,IAAM,iBAAiB,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAChE,IAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QAEtE,IAAM,YAAY,GAAG,EAAE;YACnB,CAAC,CAAC,CAAC,CAAA,MAAA,cAAc,0CAAE,SAAU,IAAG,eAAe,GAAG,iBAAiB,CAAC;YACpE,CAAC,CAAC,CAAC,eAAe,GAAG,iBAAiB,CAAC,CAAC;QAE5C,IAAM,aAAa,GAAG,CAAA,MAAA,cAAc,0CAAE,MAAO,IAAG,YAAY,CAAC;QAE7D,IAAI,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,aAAa,GAAG,iBAAiB,CAAC,CAAC;QAE5F,IAAI,UAAU,KAAK,QAAQ,CAAC,QAAQ,EAAE;YAClC,IAAM,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACzB,WAAW,GAAG,UAAU,GAAG,QAAQ,CAAC,QAAQ,GAAG,IAAI,CAAC;SACvD;QAED,IAAI,UAA4B,CAAC;QAEjC,IAAI,EAAE,EAAE;YACJ,UAAU,GAAG,QAAQ,CAAC;YACtB,IAAI,UAAU,GAAG,QAAQ,EAAE;gBAAE,UAAU,GAAG,QAAQ,CAAC;aAAE;YACrD,IAAI,WAAW,GAAG,QAAQ,EAAE;gBAAE,WAAW,GAAG,QAAQ,CAAC;aAAE;SAC1D;aAAM;YACH,UAAU,GAAG,KAAK,CAAC;YACnB,IAAI,UAAU,GAAG,OAAO,EAAE;gBAAE,UAAU,GAAG,OAAO,CAAC;aAAE;YACnD,IAAI,WAAW,GAAG,OAAO,EAAE;gBAAE,WAAW,GAAG,OAAO,CAAC;aAAE;SACxD;QAED,IAAI,IAAI,CAAC,mBAAmB,CAAC,UAAU,CAAC,EAAE;YACtC,WAAW,GAAG,UAAU,CAAC;YACzB,UAAU,GAAG,KAAK,CAAC;SACtB;QAED,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,aAAA;YACX,UAAU,YAAA;YACV,YAAY,EAAE,IAAI;YAClB,UAAU,YAAA;YACV,WAAW,EAAE,QAAQ,CAAC,MAAM;SAC/B,CAAC,CAAC;IACP,CAAC;IAEO,4DAAgC,GAAxC,UAAyC,QAAsB,EAAE,WAAmB,EAAE,EAAmB;QAAzG,iBA0BC;QA1BqF,mBAAA,EAAA,UAAmB;QACrG,oEAAoE;QACpE,kEAAkE;QAClE,kEAAkE;QAClE,6DAA6D;QAC7D,qEAAqE;QACrE,qEAAqE;QACrE,2BAA2B;QAC3B,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,EAAE,WAAW;YACxB,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK;YACjC,YAAY,EAAE,IAAI;YAClB,UAAU,EAAE,WAAW;YACvB,WAAW,EAAE,QAAQ,CAAC,MAAM;SAC/B,CAAC,CAAC;QACH,UAAU,CAAC;YACP,IAAM,UAAU,GAAG,KAAI,CAAC,8BAA8B,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAErE,KAAI,CAAC,UAAU,CAAC;gBACZ,WAAW,EAAE,WAAW;gBACxB,UAAU,EAAE,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK;gBACjC,YAAY,EAAE,IAAI;gBAClB,UAAU,EAAE,UAAU;gBACtB,WAAW,EAAE,QAAQ,CAAC,MAAM;aAC/B,CAAC,CAAC;QACP,CAAC,EAAE,EAAE,CAAC,CAAC;IACX,CAAC;IAEO,0DAA8B,GAAtC,UAAuC,QAAsB,EAAE,EAAmB;QAAnB,mBAAA,EAAA,UAAmB;;QAC9E,IAAM,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACzB,IAAM,eAAe,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACjD,IAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAE3D,IAAI,QAAQ,GAAG,CAAC,CAAC;QACjB,IAAI,YAAY,GAAG,QAAQ,CAAC,QAAQ,CAAC;QAErC,OAAO,YAAY,IAAI,CAAC,IAAI,YAAY,IAAI,YAAY,EAAE;YACtD,IAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,YAAY,CAAC,CAAC;YAE9D,IAAI,WAAW,EAAE;gBACb,IAAM,iBAAiB,SAAG,WAAW,CAAC,SAAS,uCAAI,CAAC,EAAA,CAAC;gBAErD,IAAI,QAAQ,GAAG,iBAAiB,GAAG,eAAe,EAAE;oBAAE,MAAM;iBAAE;gBAC9D,QAAQ,IAAI,iBAAiB,CAAC;aACjC;YAED,YAAY,IAAI,IAAI,CAAC;SACxB;QAED,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC,CAAC;IAC7D,CAAC;IAEO,6CAAiB,GAAzB;QACI,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,EAAE,CAAC;QACxD,IAAM,cAAc,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,EAAE,CAAC;QAC3E,IAAM,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,EAAE,CAAC;QACnE,IAAI,eAAe,GAAG,cAAc,CAAC,MAAM,GAAG,cAAc,CAAC,GAAG,CAAC;QAEjE,IAAI,IAAI,CAAC,YAAY,CAAC,yBAAyB,EAAE,CAAC,yBAAyB,EAAE,EAAE;YAC3E,eAAe,IAAI,cAAc,CAAC;SACrC;QAED,OAAO,eAAe,CAAC;IAC3B,CAAC;IAEO,+CAAmB,GAA3B,UAA4B,QAAgB;QACxC,IAAM,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QACtD,IAAI,CAAC,OAAO,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAE/B,IAAM,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QAEpC,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEpD,OAAO,SAAS,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAChD,CAAC;IAEO,iDAAqB,GAA7B,UAA8B,GAAW,EAAE,QAAsB;QAC7D,IAAM,WAAW,GAAG,IAAI,CAAC,qBAAqB,CAAC,kBAAkB,CAAC,GAAG,EAAE,QAAQ,EAAE,IAAI,CAAE,CAAC;QAChF,IAAA,+BAAQ,EAAE,2BAAM,CAAiB;QAEzC,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,EAAE,QAAQ;YACrB,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,MAAM;YACpB,UAAU,EAAE,QAAQ;YACpB,WAAW,EAAE,MAAM;SACtB,CAAC,CAAC;IACP,CAAC;IAED,+FAA+F;IAC/F,uFAAuF;IAC/E,0CAAc,GAAtB,UAAuB,GAAW;QAC9B,IAAM,OAAO,GAAG,GAAG,KAAK,OAAO,CAAC,SAAS,CAAC;QAC1C,IAAM,UAAU,GAAa,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACvE,IAAM,cAAc,GAAG,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAClE,IAAM,WAAW,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAE7G,IAAI,CAAC,UAAU,CAAC;YACZ,WAAW,EAAE,WAAW;YACxB,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,cAAc;YAC5B,UAAU,EAAE,WAAW;YACvB,WAAW,EAAE,cAAc;SAC9B,CAAC,CAAC;IACP,CAAC;IAED,2BAA2B;IACpB,wCAAY,GAAnB,UAAoB,QAA4B,EAAE,aAA4B;QAC1E,IAAM,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAC;QACzC,IAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,SAAS,EAAE,aAAa,CAAC,CAAC;QAErF,IAAI,eAAe,EAAE;YACjB,oGAAoG;YACpG,mDAAmD;YACnD,aAAa,CAAC,cAAc,EAAE,CAAC;YAC/B,OAAO;SACV;QAED,gGAAgG;QAChG,aAAa;QACb,IAAI,SAAS,EAAE;YACL,IAAA,8BAAmD,EAAjD,sBAAQ,EAAE,wBAAuC,CAAC;YAC1D,IAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;YAClG,IAAI,QAAQ,EAAE;gBACV,aAAa,CAAC,cAAc,EAAE,CAAC;gBAC/B,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;aACpD;SACJ;aAAM;YACH,yFAAyF;YACzF,sFAAsF;YACtF,iBAAiB;YACjB,IAAI,QAAQ,YAAY,QAAQ,EAAE;gBAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aAC5B;YAED,IAAI,IAAI,CAAC,YAAY,CAAC,0BAA0B,CAAC,SAAS,CAAC,EAAE;gBACzD,aAAa,CAAC,cAAc,EAAE,CAAC;aAClC;SACJ;IACL,CAAC;IAED,iBAAiB;IACV,yCAAa,GAApB,UAAqB,SAAkB,EAAE,KAAqB;QAC1D,IAAM,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,CAAC;QACvD,oCAAoC;QACpC,IAAI,CAAC,WAAW,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEnC,IAAI,SAAS,GAA8B,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAE/E,sEAAsE;QACtE,8CAA8C;QAC9C,IAAI,CAAC,SAAS,EAAE;YACZ,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;YAC3D,IAAI,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,EAAE;gBACxC,OAAO,KAAK,CAAC;aAChB;SACJ;QAED,OAAO,IAAI,CAAC,mBAAmB,CAAC,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;IACjE,CAAC;IAEO,+CAAmB,GAA3B,UAA4B,QAA4B,EAAE,SAAkB,EAAE,KAAqB;QAC/F,IAAI,OAAO,GAAG,QAAQ,CAAC,SAAS,EAAE,CAAC;QAEnC,wFAAwF;QACxF,IAAI,CAAC,OAAO,IAAI,QAAQ,YAAY,QAAQ,EAAE;YAC1C,IAAM,IAAI,GAAG,QAAoB,CAAC;YAClC,IAAM,GAAG,GAAG,IAAI,CAAC,UAAU,EAAE,CAAC;YAC9B,IAAI,GAAG,EAAE;gBACL,OAAO,GAAG,GAAG,CAAC,SAAS,EAAE,CAAC;aAC7B;SACJ;QAED,IAAI,GAAY,CAAC;QAEjB,IAAI,OAAO,EAAE;YACT,iEAAiE;YACjE,IAAI,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,EAAE;gBACzC,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAoB,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;aAC3E;iBAAM;gBACH,GAAG,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAoB,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;aAC5E;SACJ;aAAM;YACH,GAAG,GAAG,IAAI,CAAC,wBAAwB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;SAC5D;QAED,2EAA2E;QAC3E,OAAO,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC,gBAAgB,EAAE,CAAC;IACzD,CAAC;IAEO,iDAAqB,GAA7B,UAA8B,YAAsB,EAAE,SAAkB,EAAE,KAAkC;QAAlC,sBAAA,EAAA,YAAkC;QACxG,IAAM,WAAW,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;QAEnD,0EAA0E;QAC1E,2EAA2E;QAC3E,4EAA4E;QAC5E,2CAA2C;QAC3C,YAAY,CAAC,WAAW,EAAE,CAAC;QAE3B,sCAAsC;QACtC,IAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,SAAS,EAAE,IAAI,CAAa,CAAC;QAEtF,IAAI,QAAQ,IAAI,IAAI,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEvC,oGAAoG;QACpG,mDAAmD;QACnD,QAAQ,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;QAC/C,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAC1B,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,YAAsB,EAAE,SAAkB,EAAE,KAAkC;QAAlC,sBAAA,EAAA,YAAkC;QACvG,IAAM,WAAW,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;QAEnD,sCAAsC;QACtC,IAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,WAAW,EAAE,SAAS,EAAE,IAAI,CAAa,CAAC;QACtF,IAAI,QAAQ,IAAI,IAAI,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEvC,IAAM,OAAO,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;QAE3C,IAAM,gBAAgB,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QAC1D,IAAM,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAElD,IAAM,SAAS,GAAG,OAAO,IAAI,WAAW,CAAC,QAAQ,KAAK,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC;QAEtH,IAAI,gBAAgB,EAAE;YAClB,YAAY,CAAC,mBAAmB,EAAE,CAAC;SACtC;QAED,IAAI,CAAC,SAAS,EAAE;YACZ,IAAM,IAAI,GAAG,YAAY,CAAC,UAAU,EAAE,CAAC;YACvC,IAAK,CAAC,WAAW,EAAE,CAAC;YAEpB,IAAM,IAAI,GAAG,QAAQ,CAAC,UAAU,EAAE,CAAC;YACnC,IAAK,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;SACjE;QAED,IAAI,YAAY,EAAE;YACd,QAAQ,CAAC,kBAAkB,EAAE,CAAC;YAC9B,QAAQ,CAAC,SAAS,EAAE,CAAC;SACxB;aAAM;YACH,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAC5B;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,oDAAwB,GAAhC,UAAiC,YAAgC,EAAE,SAAkB;QACjF,IAAM,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACnE,IAAI,OAAqB,CAAC;QAE1B,IAAI,YAAY,YAAY,OAAO,EAAE;YACjC,OAAO,yBACA,YAAY,CAAC,cAAc,EAAE,KAChC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,GACnE,CAAC;SACL;aAAM;YACH,OAAO,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;SAC5C;QACD,sCAAsC;QACtC,IAAM,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAEvE,oGAAoG;QACpG,mDAAmD;QACnD,IAAI,QAAQ,YAAY,QAAQ,EAAE;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAC5B;aAAM,IAAI,QAAQ,EAAE;YACjB,OAAO,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE,SAAS,CAAC,CAAC;SAC5E;QAED,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC;IAC5B,CAAC;IAED,yDAAyD;IACzD,mEAAmE;IAC3D,iDAAqB,GAA7B,UAA8B,gBAA8B,EAAE,SAAkB,EAAE,YAAqB;QACnG,IAAI,YAAY,GAAwB,gBAAgB,CAAC;QAEzD,OAAO,IAAI,EAAE;YACT,IAAI,gBAAgB,KAAK,YAAY,EAAE;gBAAE,gBAAgB,GAAG,YAAY,CAAC;aAAE;YAE3E,IAAI,CAAC,SAAS,EAAE;gBACZ,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,YAAY,CAAC,CAAC;aAC1D;YACD,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC;YAErF,iDAAiD;YACjD,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC;YAEhE,IAAI,MAAM,CAAC,QAAQ,CAAC,EAAE;gBAClB,IAAM,MAAM,GAA2C;oBACnD,SAAS,EAAE,SAAS;oBACpB,OAAO,EAAE,YAAY;oBACrB,oBAAoB,EAAE,gBAAgB;oBACtC,gBAAgB,EAAE,YAAY,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,IAAI;iBACvD,CAAC;gBACF,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAClC,IAAI,MAAM,CAAC,QAAQ,CAAC,EAAE;oBAClB,IAAK,QAAgB,CAAC,QAAQ,EAAE;wBAC5B,MAAM,CAAC,cAAQ,OAAO,CAAC,IAAI,CAAC,sJAAsJ,CAAC,CAAC,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC;wBACnN,QAAQ,CAAC,SAAS,GAAI,QAAgB,CAAC,QAAQ,CAAC;qBACnD;oBACD,YAAY,GAAG;wBACX,QAAQ,EAAE,QAAQ,CAAC,QAAQ;wBAC3B,MAAM,EAAE,QAAQ,CAAC,MAAM;wBACvB,SAAS,EAAE,QAAQ,CAAC,SAAS;qBAChB,CAAC;iBACrB;qBAAM;oBACH,YAAY,GAAG,IAAI,CAAC;iBACvB;aACJ;YAED,oFAAoF;YACpF,mEAAmE;YACnE,IAAI,CAAC,YAAY,EAAE;gBAAE,OAAO,IAAI,CAAC;aAAE;YAEnC,IAAI,YAAY,CAAC,QAAQ,GAAG,CAAC,EAAE;gBAC3B,IAAM,SAAS,GAAG,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;gBAEnE,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC;oBAClC,cAAc,EAAE;wBACZ,cAAc,EAAE,SAAS,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC;wBACnD,MAAM,EAAE,YAAY,CAAC,MAAM;qBAC9B;iBACJ,CAAC,CAAC;gBAEH,OAAO,IAAI,CAAC;aACf;YAED,+EAA+E;YAC/E,kFAAkF;YAClF,sFAAsF;YACtF,oEAAoE;YACpE,2FAA2F;YAC3F,IAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC;YAC5D,IAAI,YAAY,IAAI,CAAC,WAAW,EAAE;gBAC9B,IAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;gBACzD,IAAI,CAAC,cAAc,EAAE;oBAAE,SAAS;iBAAE;aACrC;YAED,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;YAErC,0FAA0F;YAC1F,+EAA+E;YAC/E,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;YAEtD,wDAAwD;YACxD,iDAAiD;YACjD,IAAI,CAAC,QAAQ,EAAE;gBACX,IAAM,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;gBAC5D,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE;oBAC5B,SAAS;iBACZ;qBAAM;oBACH,OAAO,GAAG,CAAC;iBACd;aACJ;YAED,IAAI,QAAQ,CAAC,mBAAmB,EAAE,EAAE;gBAAE,SAAS;aAAE;YAEjD,kGAAkG;YAClG,2CAA2C;YAC3C,IAAI,IAAI,CAAC,YAAY,EAAE;gBACnB,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;aAClD;YAED,0DAA0D;YAC1D,OAAO,QAAQ,CAAC;SACnB;IACL,CAAC;IAEO,0CAAc,GAAtB,UAAuB,IAAkB;QACrC,IAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAEhD,IAAI,OAAO,EAAE;YACT,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;SAC9C;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAEM,6CAAiB,GAAxB,UAAyB,YAA0B;QAC/C,IAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,YAAY,CAAC,CAAC;QAChE,IAAI,CAAC,OAAO,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAC9B,OAAO,OAAO,CAAC,WAAW,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACpD,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,IAAkB;QAC3C,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,UAAU,EAAE;YACzC,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC7D;QAED,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,aAAa,EAAE;YAC5C,OAAO,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAChE;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;IAED,gGAAgG;IAChG,yFAAyF;IAClF,8CAAkB,GAAzB,UAA0B,KAA2B,EAAE,GAAW,EAAE,WAAyB,EAAE,iBAA0B;QACrH,8FAA8F;QAC9F,IAAI,QAAQ,GAAwB,WAAW,CAAC;QAChD,IAAI,aAAa,GAAG,KAAK,CAAC;QAE1B,OAAO,QAAQ,IAAI,CAAC,QAAQ,KAAK,WAAW,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC,EAAE;YAClF,2EAA2E;YAC3E,2EAA2E;YAC3E,mBAAmB;YACnB,IAAI,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,EAAE;gBACvC,IAAI,GAAG,KAAK,OAAO,CAAC,IAAI,EAAE;oBACtB,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;iBAClD;aACJ;iBAAM,IAAI,GAAG,KAAK,OAAO,CAAC,KAAK,EAAE;gBAC9B,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;aAClD;YAED,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,kBAAkB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;YAExE,gFAAgF;YAChF,aAAa,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;SACrC;QAED,IAAI,aAAa,IAAI,KAAK,IAAI,KAAK,CAAC,GAAG,KAAK,OAAO,CAAC,EAAE,EAAE;YACpD,QAAQ,GAAG;gBACP,QAAQ,EAAE,CAAC,CAAC;gBACZ,SAAS,EAAE,IAAI;gBACf,MAAM,EAAE,WAAW,CAAC,MAAM;aAC7B,CAAC;SACL;QAED,gGAAgG;QAChG,kFAAkF;QAClF,IAAI,iBAAiB,EAAE;YACnB,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,CAAC;YACrE,IAAI,MAAM,CAAC,QAAQ,CAAC,EAAE;gBAClB,IAAM,MAAM,GAAgD;oBACxD,GAAG,EAAE,GAAG;oBACR,oBAAoB,EAAE,WAAW;oBACjC,gBAAgB,EAAE,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI;oBAC5C,KAAK,EAAE,KAAK;iBACf,CAAC;gBACF,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAClC,IAAI,MAAM,CAAC,QAAQ,CAAC,EAAE;oBAClB,IAAK,QAAgB,CAAC,QAAQ,EAAE;wBAC5B,MAAM,CAAC,cAAQ,OAAO,CAAC,IAAI,CAAC,sJAAsJ,CAAC,CAAC,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC;wBACnN,QAAQ,CAAC,SAAS,GAAI,QAAgB,CAAC,QAAQ,CAAC;qBACnD;oBACD,QAAQ,GAAG;wBACP,SAAS,EAAE,QAAQ,CAAC,SAAS;wBAC7B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;wBAC3B,MAAM,EAAE,QAAQ,CAAC,MAAM;qBACV,CAAC;iBACrB;qBAAM;oBACH,QAAQ,GAAG,IAAI,CAAC;iBACnB;aACJ;SACJ;QAED,4FAA4F;QAC5F,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO;SAAE;QAE1B,IAAI,QAAQ,CAAC,QAAQ,GAAG,CAAC,EAAE;YACvB,IAAM,SAAS,GAAG,IAAI,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YAEnE,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC;gBAClC,cAAc,EAAE,EAAE,cAAc,EAAE,SAAS,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE;gBAC/F,KAAK,EAAE,KAAK,IAAI,SAAS;aAC5B,CAAC,CAAC;YAEH,OAAO;SACV;QAED,yEAAyE;QACzE,yEAAyE;QACzE,IAAM,kBAAkB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;QAChE,IAAI,kBAAkB,EAAE;YACpB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC;SAC1C;aAAM;YACH,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;SACzC;IACL,CAAC;IAEO,iDAAqB,GAA7B,UAA8B,YAA0B;QACpD,sEAAsE;QACtE,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QACrC,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAEtD,+EAA+E;QAC/E,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE/B,YAAY,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;QAC1C,iGAAiG;QACjG,+FAA+F;QAC/F,6FAA6F;QAC7F,+FAA+F;QAC/F,gBAAgB;QAChB,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAErC,OAAO,YAAY,CAAC;IACxB,CAAC;IAEO,kDAAsB,GAA9B,UAA+B,QAAoC,EAAE,SAA0B;QAA1B,0BAAA,EAAA,iBAA0B;QAC3F,IAAM,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,sBAAsB,EAAE,CAAC;QACnE,IAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QAC5D,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEzD,IAAM,kBAAkB,GAAG,IAAI,CAAC,YAAY,CAAC,cAAc,EAAE,CAAC;QAE9D,IAAM,YAAY,GAAiB;YAC/B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;YAC3B,SAAS,EAAE,QAAQ,CAAC,SAAS;YAC7B,MAAM,EAAG,QAAyB,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;SAC1G,CAAC;QAEF,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAEjC,IAAM,SAAS,GAAG,kBAAkB,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,YAAY,EAAE,kBAAkB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;QAEtH,IAAM,UAAU,GAA6B;YACzC,IAAI,EAAE,MAAM,CAAC,4BAA4B;YACzC,GAAG,EAAE,IAAI,CAAC,OAAO;YACjB,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,QAAQ,EAAE,YAAY,CAAC,QAAQ;YAC/B,SAAS,EAAE,YAAY,CAAC,SAAS;YACjC,MAAM,EAAE,YAAY,CAAC,MAAM;YAC3B,eAAe,EAAE,IAAI;YACrB,QAAQ,EAAE,YAAY,CAAC,SAAS;YAChC,SAAS,WAAA;SACZ,CAAC;QAEF,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,UAAU,CAAC,CAAC;QAE5C,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,yCAAa,GAArB,UAAsB,YAA0B;QAC5C,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAE3G,IAAI,IAAI,CAAC,YAAY,EAAE;YACnB,IAAI,CAAC,YAAY,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;SAClD;IACL,CAAC;IAEO,+CAAmB,GAA3B,UAA4B,IAAkB;QAC1C,IAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAEvD,8DAA8D;QAC9D,OAAO,CAAC,CAAC,OAAO,CAAC;IACrB,CAAC;IAEO,gDAAoB,GAA5B,UAA6B,IAAkB;QAC3C,IAAM,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAE9C,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE/B,IAAM,eAAe,GAAG,QAAQ,CAAC,kBAAkB,EAAE,CAAC;QAEtD,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAElD,OAAO;YACH,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,MAAM,EAAE,IAAI,CAAC,eAAe,CAAC;YAC7B,SAAS,EAAE,IAAI,CAAC,SAAS;SAC5B,CAAC;IACN,CAAC;IAEM,6CAAiB,GAAxB,UAAyB,QAAsB;QAC3C,iCAAiC;QACjC,IAAI,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC7E;QAED,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;SAC5E;QAED,iGAAiG;QACjG,6CAA6C;QAC7C,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,+CAA+C,EAAE,CAAC;QAEtF,oEAAoE;QACpE,IAAI,CAAC,qBAAqB,CAAC,cAAc,EAAE,CAAC;IAChD,CAAC;IAlwBuB;QAAvB,SAAS,CAAC,WAAW,CAAC;wDAAuC;IACxC;QAArB,SAAS,CAAC,SAAS,CAAC;sDAAmC;IACxB;QAA/B,SAAS,CAAC,mBAAmB,CAAC;gEAA8C;IAC/C;QAA7B,SAAS,CAAC,iBAAiB,CAAC;8DAA0C;IAC5C;QAA1B,SAAS,CAAC,cAAc,CAAC;2DAAoC;IAC1B;QAAnC,SAAS,CAAC,uBAAuB,CAAC;oEAAsD;IAC/D;QAAzB,QAAQ,CAAC,cAAc,CAAC;2DAAqC;IACpC;QAAzB,SAAS,CAAC,aAAa,CAAC;0DAAkC;IAChC;QAA1B,SAAS,CAAC,cAAc,CAAC;2DAAmC;IACnC;QAAzB,SAAS,CAAC,aAAa,CAAC;0DAAiC;IACpB;QAArC,SAAS,CAAC,yBAAyB,CAAC;sEAAyD;IAC/D;QAA9B,SAAS,CAAC,kBAAkB,CAAC;+DAA4C;IACtC;QAAnC,SAAS,CAAC,uBAAuB,CAAC;oEAAsD;IAC5D;QAA5B,SAAS,CAAC,gBAAgB,CAAC;6DAAwC;IAWpE;QADC,aAAa;0DAKb;IA9BQ,iBAAiB;QAD7B,IAAI,CAAC,mBAAmB,CAAC;OACb,iBAAiB,CAqwB7B;IAAD,wBAAC;CArwBD,AAqwBC,CArwBsC,QAAQ,GAqwB9C;SArwBY,iBAAiB","file":"navigationService.js","sourcesContent":["import { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { MouseEventService } from \"./mouseEventService\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { Column } from \"../entities/column\";\nimport { FocusService } from \"../focusService\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { IRangeService } from \"../interfaces/IRangeService\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists, missing } from \"../utils/generic\";\nimport { last } from \"../utils/array\";\nimport { KeyCode } from '../constants/keyCode';\nimport { CtrlsService } from \"../ctrlsService\";\nimport { GridBodyCtrl } from \"./gridBodyCtrl\";\nimport { CellCtrl } from \"../rendering/cell/cellCtrl\";\nimport { RowCtrl } from \"../rendering/row/rowCtrl\";\nimport { doOnce, throttle } from \"../utils/function\";\nimport { Constants } from \"../constants/constants\";\nimport { RowPosition, RowPositionUtils } from \"../entities/rowPosition\";\nimport { RowRenderer } from \"../rendering/rowRenderer\";\nimport { HeaderNavigationService } from \"../headerRendering/common/headerNavigationService\";\nimport { CellNavigationService } from \"../cellNavigationService\";\nimport { PinnedRowModel } from \"../pinnedRowModel/pinnedRowModel\";\nimport { NavigateToNextCellParams, TabToNextCellParams } from \"../entities/iCallbackParams\";\nimport { WithoutGridCommon } from \"../interfaces/iCommon\";\nimport { Events } from \"../eventKeys\";\nimport { FullWidthRowFocusedEvent } from \"../events\";\nimport { GridApi } from \"../gridApi\";\nimport { ColumnApi } from \"../columns/columnApi\";\n\ninterface NavigateParams {\n    /** The rowIndex to vertically scroll to. */\n    scrollIndex: number;\n    /** The position to put scroll index. */\n    scrollType: 'top' | 'bottom' | null;\n    /**  The column to horizontally scroll to. */\n    scrollColumn: Column | null;\n    /** For page up/down, we want to scroll to one row/column but focus another (ie. scrollRow could be stub). */\n    focusIndex: number;\n    focusColumn: Column;\n}\n\n@Bean('navigationService')\nexport class NavigationService extends BeanStub {\n\n    @Autowired('columnApi') private readonly columnApi: ColumnApi;\n    @Autowired('gridApi') private readonly gridApi: GridApi;\n    @Autowired('mouseEventService') private mouseEventService: MouseEventService;\n    @Autowired('paginationProxy') private paginationProxy: PaginationProxy;\n    @Autowired('focusService') private focusService: FocusService;\n    @Autowired('animationFrameService') private animationFrameService: AnimationFrameService;\n    @Optional('rangeService') private rangeService: IRangeService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n    @Autowired('rowRenderer') public rowRenderer: RowRenderer;\n    @Autowired('headerNavigationService') public headerNavigationService: HeaderNavigationService;\n    @Autowired(\"rowPositionUtils\") private rowPositionUtils: RowPositionUtils;\n    @Autowired(\"cellNavigationService\") private cellNavigationService: CellNavigationService;\n    @Autowired(\"pinnedRowModel\") private pinnedRowModel: PinnedRowModel;\n\n    private gridBodyCon: GridBodyCtrl;\n\n    constructor() {\n        super();\n        this.onPageDown = throttle(this.onPageDown, 100);\n        this.onPageUp = throttle(this.onPageUp, 100);\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(p => {\n            this.gridBodyCon = p.gridBodyCtrl;\n        });\n    }\n\n    public handlePageScrollingKey(event: KeyboardEvent): boolean {\n        const key = event.key;\n        const alt = event.altKey;\n        const ctrl = event.ctrlKey || event.metaKey;\n        const rangeServiceShouldHandleShift = !!this.rangeService && event.shiftKey;\n\n        const currentCell: CellPosition | null = this.mouseEventService.getCellPositionForEvent(event);\n        if (!currentCell) { return false; }\n\n        let processed = false;\n\n        switch (key) {\n            case KeyCode.PAGE_HOME:\n            case KeyCode.PAGE_END:\n                // handle home and end when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onHomeOrEndKey(key);\n                    processed = true;\n                }\n                break;\n            case KeyCode.LEFT:\n            case KeyCode.RIGHT:\n            case KeyCode.UP:\n            case KeyCode.DOWN:\n                // handle when ctrl is pressed only, if shift is pressed\n                // it will be handled by the rangeService\n                if (ctrl && !alt && !rangeServiceShouldHandleShift) {\n                    this.onCtrlUpDownLeftRight(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_DOWN:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageDown(currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_UP:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageUp(currentCell);\n                    processed = true;\n                }\n                break;\n        }\n\n        if (processed) {\n            event.preventDefault();\n        }\n\n        return processed;\n    }\n\n    private navigateTo(navigateParams: NavigateParams): void {\n        const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;\n\n        if (exists(scrollColumn) && !scrollColumn.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);\n        }\n\n        if (exists(scrollIndex)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);\n        }\n\n        // make sure the cell is rendered, needed if we are to focus\n        this.animationFrameService.flushAllFrames();\n\n        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell\n        // highlighted.\n        this.focusService.setFocusedCell(focusIndex, focusColumn, null, true);\n\n        if (this.rangeService) {\n            const cellPosition: CellPosition = { rowIndex: focusIndex, rowPinned: null, column: focusColumn };\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n    }\n\n    private onPageDown(gridCell: CellPosition): void {\n        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        const pixelsInOnePage = this.getViewportHeight();\n\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n\n        const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;\n        const currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);\n\n        if (this.columnModel.isAutoRowHeightActive()) {\n            this.navigateToNextPageWithAutoHeight(gridCell, currentPageBottomRow);\n        } else {\n            this.navigateToNextPage(gridCell, currentPageBottomRow);\n        }\n    }\n\n    private onPageUp(gridCell: CellPosition): void {\n        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n\n        const currentPageTopPixel = scrollPosition.top;\n        const currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);\n\n        if (this.columnModel.isAutoRowHeightActive()) {\n            this.navigateToNextPageWithAutoHeight(gridCell, currentPageTopRow, true);\n        } else {\n            this.navigateToNextPage(gridCell, currentPageTopRow, true);\n        }\n    }\n\n    private navigateToNextPage(gridCell: CellPosition, scrollIndex: number, up: boolean = false): void {\n        const pixelsInOnePage = this.getViewportHeight();\n        const firstRow = this.paginationProxy.getPageFirstRow();\n        const lastRow = this.paginationProxy.getPageLastRow();\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n        const currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex);\n\n        const rowPixelDiff = up\n            ? (currentRowNode?.rowHeight! - pixelsInOnePage - pagingPixelOffset)\n            : (pixelsInOnePage - pagingPixelOffset);\n\n        const nextCellPixel = currentRowNode?.rowTop! + rowPixelDiff;\n\n        let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n\n        if (focusIndex === gridCell.rowIndex) {\n            const diff = up ? -1 : 1;\n            scrollIndex = focusIndex = gridCell.rowIndex + diff;\n        }\n\n        let scrollType: 'top' | 'bottom';\n\n        if (up) {\n            scrollType = 'bottom';\n            if (focusIndex < firstRow) { focusIndex = firstRow; }\n            if (scrollIndex < firstRow) { scrollIndex = firstRow; }\n        } else {\n            scrollType = 'top';\n            if (focusIndex > lastRow) { focusIndex = lastRow; }\n            if (scrollIndex > lastRow) { scrollIndex = lastRow; }\n        }\n\n        if (this.isRowTallerThanView(focusIndex)) {\n            scrollIndex = focusIndex;\n            scrollType = 'top';\n        }\n\n        this.navigateTo({\n            scrollIndex,\n            scrollType,\n            scrollColumn: null,\n            focusIndex,\n            focusColumn: gridCell.column\n        });\n    }\n\n    private navigateToNextPageWithAutoHeight(gridCell: CellPosition, scrollIndex: number, up: boolean = false): void {\n        // because autoHeight will calculate the height of rows after scroll\n        // first we scroll towards the required point, then we add a small\n        // delay to allow the height to be recalculated, check which index\n        // should be focused and then finally navigate to that index.\n        // TODO: we should probably have an event fired once to scrollbar has\n        // settled and all rowHeights have been calculated instead of relying\n        // on a setTimeout of 50ms.\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: up ? 'bottom' : 'top',\n            scrollColumn: null,\n            focusIndex: scrollIndex,\n            focusColumn: gridCell.column\n        });\n        setTimeout(() => {\n            const focusIndex = this.getNextFocusIndexForAutoHeight(gridCell, up);\n\n            this.navigateTo({\n                scrollIndex: scrollIndex,\n                scrollType: up ? 'bottom' : 'top',\n                scrollColumn: null,\n                focusIndex: focusIndex,\n                focusColumn: gridCell.column\n            });\n        }, 50);\n    }\n\n    private getNextFocusIndexForAutoHeight(gridCell: CellPosition, up: boolean = false): number {\n        const step = up ? -1 : 1;\n        const pixelsInOnePage = this.getViewportHeight();\n        const lastRowIndex = this.paginationProxy.getPageLastRow();\n\n        let pixelSum = 0;\n        let currentIndex = gridCell.rowIndex;\n\n        while (currentIndex >= 0 && currentIndex <= lastRowIndex) {\n            const currentCell = this.paginationProxy.getRow(currentIndex);\n\n            if (currentCell) {\n                const currentCellHeight = currentCell.rowHeight ?? 0;\n\n                if (pixelSum + currentCellHeight > pixelsInOnePage) { break; }\n                pixelSum += currentCellHeight;\n            }\n\n            currentIndex += step;\n        }\n\n        return Math.max(0, Math.min(currentIndex, lastRowIndex));\n    }\n\n    private getViewportHeight(): number {\n        const gridBodyCon = this.ctrlsService.getGridBodyCtrl();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        const scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n        if (this.ctrlsService.getCenterRowContainerCtrl().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n\n        return pixelsInOnePage;\n    }\n\n    private isRowTallerThanView(rowIndex: number): boolean {\n        const rowNode = this.paginationProxy.getRow(rowIndex);\n        if (!rowNode) { return false; }\n\n        const rowHeight = rowNode.rowHeight;\n\n        if (typeof rowHeight !== 'number') { return false; }\n\n        return rowHeight > this.getViewportHeight();\n    }\n\n    private onCtrlUpDownLeftRight(key: string, gridCell: CellPosition): void {\n        const cellToFocus = this.cellNavigationService.getNextCellToFocus(key, gridCell, true)!;\n        const { rowIndex, column } = cellToFocus;\n\n        this.navigateTo({\n            scrollIndex: rowIndex,\n            scrollType: null,\n            scrollColumn: column,\n            focusIndex: rowIndex,\n            focusColumn: column\n        });\n    }\n\n    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring\n    // same cell into view (which means either scroll all the way up, or all the way down).\n    private onHomeOrEndKey(key: string): void {\n        const homeKey = key === KeyCode.PAGE_HOME;\n        const allColumns: Column[] = this.columnModel.getAllDisplayedColumns();\n        const columnToSelect = homeKey ? allColumns[0] : last(allColumns);\n        const scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: scrollIndex,\n            focusColumn: columnToSelect\n        });\n    }\n\n    // result of keyboard event\n    public onTabKeyDown(previous: CellCtrl | RowCtrl, keyboardEvent: KeyboardEvent): void {\n        const backwards = keyboardEvent.shiftKey;\n        const movedToNextCell = this.tabToNextCellCommon(previous, backwards, keyboardEvent);\n\n        if (movedToNextCell) {\n            // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n            // to the normal tabbing so user can exit the grid.\n            keyboardEvent.preventDefault();\n            return;\n        }\n\n        // if we didn't move to next cell, then need to tab out of the cells, ie to the header (if going\n        // backwards)\n        if (backwards) {\n            const { rowIndex, rowPinned } = previous.getRowPosition();\n            const firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();\n            if (firstRow) {\n                keyboardEvent.preventDefault();\n                this.focusService.focusLastHeader(keyboardEvent);\n            }\n        } else {\n            // if the case it's a popup editor, the focus is on the editor and not the previous cell.\n            // in order for the tab navigation to work, we need to focus the browser back onto the\n            // previous cell.\n            if (previous instanceof CellCtrl) {\n                previous.focusCell(true);\n            }\n\n            if (this.focusService.focusNextGridCoreContainer(backwards)) {\n                keyboardEvent.preventDefault();\n            }\n        }\n    }\n\n    // comes from API\n    public tabToNextCell(backwards: boolean, event?: KeyboardEvent): boolean {\n        const focusedCell = this.focusService.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (!focusedCell) { return false; }\n\n        let cellOrRow: CellCtrl | RowCtrl | null = this.getCellByPosition(focusedCell);\n\n        // if cell is not rendered, means user has scrolled away from the cell\n        // or that the focusedCell is a Full Width Row\n        if (!cellOrRow) {\n            cellOrRow = this.rowRenderer.getRowByPosition(focusedCell);\n            if (!cellOrRow || !cellOrRow.isFullWidth()) {\n                return false;\n            }\n        }\n\n        return this.tabToNextCellCommon(cellOrRow, backwards, event);\n    }\n\n    private tabToNextCellCommon(previous: CellCtrl | RowCtrl, backwards: boolean, event?: KeyboardEvent): boolean {\n        let editing = previous.isEditing();\n\n        // if cell is not editing, there is still chance row is editing if it's Full Row Editing\n        if (!editing && previous instanceof CellCtrl) {\n            const cell = previous as CellCtrl;\n            const row = cell.getRowCtrl();\n            if (row) {\n                editing = row.isEditing();\n            }\n        }\n\n        let res: boolean;\n\n        if (editing) {\n            // if we are editing, we know it's not a Full Width Row (RowComp)\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previous as CellCtrl, backwards, event);\n            } else {\n                res = this.moveToNextEditingCell(previous as CellCtrl, backwards, event);\n            }\n        } else {\n            res = this.moveToNextCellNotEditing(previous, backwards);\n        }\n\n        // if a cell wasn't found, it's possible that focus was moved to the header\n        return res || !!this.focusService.getFocusedHeader();\n    }\n\n    private moveToNextEditingCell(previousCell: CellCtrl, backwards: boolean, event: KeyboardEvent | null = null): boolean {\n        const previousPos = previousCell.getCellPosition();\n\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousCell.stopEditing();\n\n        // find the next cell to start editing\n        const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true) as CellCtrl;\n\n        if (nextCell == null) { return false; }\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        nextCell.startEditing(null, null, true, event);\n        nextCell.focusCell(false);\n        return true;\n    }\n\n    private moveToNextEditingRow(previousCell: CellCtrl, backwards: boolean, event: KeyboardEvent | null = null): boolean {\n        const previousPos = previousCell.getCellPosition();\n\n        // find the next cell to start editing\n        const nextCell = this.findNextCellToFocusOn(previousPos, backwards, true) as CellCtrl;\n        if (nextCell == null) { return false; }\n\n        const nextPos = nextCell.getCellPosition();\n\n        const previousEditable = this.isCellEditable(previousPos);\n        const nextEditable = this.isCellEditable(nextPos);\n\n        const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;\n\n        if (previousEditable) {\n            previousCell.setFocusOutOnEditor();\n        }\n\n        if (!rowsMatch) {\n            const pRow = previousCell.getRowCtrl();\n            pRow!.stopEditing();\n\n            const nRow = nextCell.getRowCtrl();\n            nRow!.startRowEditing(undefined, undefined, undefined, event);\n        }\n\n        if (nextEditable) {\n            nextCell.setFocusInOnEditor();\n            nextCell.focusCell();\n        } else {\n            nextCell.focusCell(true);\n        }\n\n        return true;\n    }\n\n    private moveToNextCellNotEditing(previousCell: CellCtrl | RowCtrl, backwards: boolean): boolean {\n        const displayedColumns = this.columnModel.getAllDisplayedColumns();\n        let cellPos: CellPosition;\n\n        if (previousCell instanceof RowCtrl) {\n            cellPos = {\n                ...previousCell.getRowPosition(),\n                column: backwards ? displayedColumns[0] : last(displayedColumns)\n            };\n        } else {\n            cellPos = previousCell.getCellPosition();\n        }\n        // find the next cell to start editing\n        const nextCell = this.findNextCellToFocusOn(cellPos, backwards, false);\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (nextCell instanceof CellCtrl) {\n            nextCell.focusCell(true);\n        } else if (nextCell) {\n            return this.tryToFocusFullWidthRow(nextCell.getRowPosition(), backwards);\n        }\n\n        return exists(nextCell);\n    }\n\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    private findNextCellToFocusOn(previousPosition: CellPosition, backwards: boolean, startEditing: boolean): CellCtrl | RowCtrl | null {\n        let nextPosition: CellPosition | null = previousPosition;\n\n        while (true) {\n            if (previousPosition !== nextPosition) { previousPosition = nextPosition; }\n\n            if (!backwards) {\n                nextPosition = this.getLastCellOfColSpan(nextPosition);\n            }\n            nextPosition = this.cellNavigationService.getNextTabbedCell(nextPosition, backwards);\n\n            // allow user to override what cell to go to next\n            const userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n\n            if (exists(userFunc)) {\n                const params: WithoutGridCommon<TabToNextCellParams> = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: previousPosition,\n                    nextCellPosition: nextPosition ? nextPosition : null\n                };\n                const userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        doOnce(() => { console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextPosition = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    } as CellPosition;\n                } else {\n                    nextPosition = null;\n                }\n            }\n\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextPosition) { return null; }\n\n            if (nextPosition.rowIndex < 0) {\n                const headerLen = this.headerNavigationService.getHeaderRowCount();\n\n                this.focusService.focusHeaderPosition({\n                    headerPosition: {\n                        headerRowIndex: headerLen + (nextPosition.rowIndex),\n                        column: nextPosition.column\n                    }\n                });\n\n                return null;\n            }\n\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            // note - for full row edit, we do focus non-editable cells, as the row stays in edit mode.\n            const fullRowEdit = this.gridOptionsWrapper.isFullRowEdit();\n            if (startEditing && !fullRowEdit) {\n                const cellIsEditable = this.isCellEditable(nextPosition);\n                if (!cellIsEditable) { continue; }\n            }\n\n            this.ensureCellVisible(nextPosition);\n\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            const nextCell = this.getCellByPosition(nextPosition);\n\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (!nextCell) {\n                const row = this.rowRenderer.getRowByPosition(nextPosition);\n                if (!row || !row.isFullWidth()) {\n                    continue;\n                } else {\n                    return row;\n                }\n            }\n\n            if (nextCell.isSuppressNavigable()) { continue; }\n\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeService) {\n                this.rangeService.setRangeToCell(nextPosition);\n            }\n\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCell;\n        }\n    }\n\n    private isCellEditable(cell: CellPosition): boolean {\n        const rowNode = this.lookupRowNodeForCell(cell);\n\n        if (rowNode) {\n            return cell.column.isCellEditable(rowNode);\n        }\n\n        return false;\n    }\n\n    public getCellByPosition(cellPosition: CellPosition): CellCtrl | null {\n        const rowCtrl = this.rowRenderer.getRowByPosition(cellPosition);\n        if (!rowCtrl) { return null; }\n        return rowCtrl.getCellCtrl(cellPosition.column);\n    }\n\n    private lookupRowNodeForCell(cell: CellPosition) {\n        if (cell.rowPinned === Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n\n        if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n\n        return this.paginationProxy.getRow(cell.rowIndex);\n    }\n\n    // we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    public navigateToNextCell(event: KeyboardEvent | null, key: string, currentCell: CellPosition, allowUserOverride: boolean) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        let nextCell: CellPosition | null = currentCell;\n        let hitEdgeOfGrid = false;\n\n        while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === KeyCode.LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            } else if (key === KeyCode.RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            hitEdgeOfGrid = missing(nextCell);\n        }\n\n        if (hitEdgeOfGrid && event && event.key === KeyCode.UP) {\n            nextCell = {\n                rowIndex: -1,\n                rowPinned: null,\n                column: currentCell.column\n            };\n        }\n\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            const userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (exists(userFunc)) {\n                const params: WithoutGridCommon<NavigateToNextCellParams> = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event\n                };\n                const userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        doOnce(() => { console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    } as CellPosition;\n                } else {\n                    nextCell = null;\n                }\n            }\n        }\n\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) { return; }\n\n        if (nextCell.rowIndex < 0) {\n            const headerLen = this.headerNavigationService.getHeaderRowCount();\n\n            this.focusService.focusHeaderPosition({\n                headerPosition: { headerRowIndex: headerLen + (nextCell.rowIndex), column: currentCell.column },\n                event: event || undefined\n            });\n\n            return;\n        }\n\n        // in case we have col spanning we get the cellComp and use it to get the\n        // position. This was we always focus the first cell inside the spanning.\n        const normalisedPosition = this.getNormalisedPosition(nextCell);\n        if (normalisedPosition) {\n            this.focusPosition(normalisedPosition);\n        } else {\n            this.tryToFocusFullWidthRow(nextCell);\n        }\n    }\n\n    private getNormalisedPosition(cellPosition: CellPosition): CellPosition | null {\n        // ensureCellVisible first, to make sure cell at position is rendered.\n        this.ensureCellVisible(cellPosition);\n        const cellComp = this.getCellByPosition(cellPosition);\n\n        // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n        if (!cellComp) { return null; }\n\n        cellPosition = cellComp.getCellPosition();\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(cellPosition);\n\n        return cellPosition;\n    }\n\n    private tryToFocusFullWidthRow(position: CellPosition | RowPosition, backwards: boolean = false): boolean {\n        const displayedColumns = this.columnModel.getAllDisplayedColumns();\n        const rowComp = this.rowRenderer.getRowByPosition(position);\n        if (!rowComp || !rowComp.isFullWidth()) { return false; }\n\n        const currentCellFocused = this.focusService.getFocusedCell();\n\n        const cellPosition: CellPosition = {\n            rowIndex: position.rowIndex,\n            rowPinned: position.rowPinned,\n            column: (position as CellPosition).column || (backwards ? last(displayedColumns) : displayedColumns[0])\n        };\n\n        this.focusPosition(cellPosition);\n\n        const fromBelow = currentCellFocused != null ? this.rowPositionUtils.before(cellPosition, currentCellFocused) : false;\n\n        const focusEvent: FullWidthRowFocusedEvent = {\n            type: Events.EVENT_FULL_WIDTH_ROW_FOCUSED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            rowIndex: cellPosition.rowIndex,\n            rowPinned: cellPosition.rowPinned,\n            column: cellPosition.column,\n            isFullWidthCell: true,\n            floating: cellPosition.rowPinned,\n            fromBelow\n        };\n\n        this.eventService.dispatchEvent(focusEvent);\n\n        return true;\n    }\n\n    private focusPosition(cellPosition: CellPosition) {\n        this.focusService.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n\n        if (this.rangeService) {\n            this.rangeService.setRangeToCell(cellPosition);\n        }\n    }\n\n    private isValidNavigateCell(cell: CellPosition): boolean {\n        const rowNode = this.rowPositionUtils.getRowNode(cell);\n\n        // we do not allow focusing on detail rows and full width rows\n        return !!rowNode;\n    }\n\n    private getLastCellOfColSpan(cell: CellPosition): CellPosition {\n        const cellCtrl = this.getCellByPosition(cell);\n\n        if (!cellCtrl) { return cell; }\n\n        const colSpanningList = cellCtrl.getColSpanningList();\n\n        if (colSpanningList.length === 1) { return cell; }\n\n        return {\n            rowIndex: cell.rowIndex,\n            column: last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    }\n\n    public ensureCellVisible(gridCell: CellPosition): void {\n        // this scrolls the row into view\n        if (missing(gridCell.rowPinned)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);\n        }\n\n        if (!gridCell.column.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);\n        }\n\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter();\n\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    }\n}\n"]}