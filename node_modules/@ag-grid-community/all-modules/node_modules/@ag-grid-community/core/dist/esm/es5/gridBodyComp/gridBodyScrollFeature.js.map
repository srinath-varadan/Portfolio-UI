{"version":3,"sources":["../../../src/ts/gridBodyComp/gridBodyScrollFeature.ts"],"names":[],"mappings":"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","file":"gridBodyScrollFeature.js","sourcesContent":["import { Autowired, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { getInnerHeight, getScrollLeft, isRtlNegativeScroll, setScrollLeft } from \"../utils/dom\";\nimport { CtrlsService } from \"../ctrlsService\";\nimport { Events } from \"../eventKeys\";\nimport { debounce } from \"../utils/function\";\nimport { BodyScrollEvent, BodyScrollEndEvent } from \"../events\";\nimport { isIOSUserAgent } from \"../utils/browser\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { ColumnApi } from \"../columns/columnApi\";\nimport { GridApi } from \"../gridApi\";\nimport { Constants } from \"../constants/constants\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { RowContainerHeightService } from \"../rendering/rowContainerHeightService\";\nimport { RowRenderer } from \"../rendering/rowRenderer\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { RowContainerCtrl } from \"./rowContainer/rowContainerCtrl\";\nimport { Column } from \"../entities/column\";\n\ntype ScrollDirection = 'horizontal' | 'vertical';\n\nexport class GridBodyScrollFeature extends BeanStub {\n\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n    @Autowired('animationFrameService') private animationFrameService: AnimationFrameService;\n    @Autowired('columnApi') private columnApi: ColumnApi;\n    @Autowired('gridApi') private gridApi: GridApi;\n    @Autowired('paginationProxy') private paginationProxy: PaginationProxy;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('rowContainerHeightService') private heightScaler: RowContainerHeightService;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    private enableRtl: boolean;\n\n    private lastHorizontalScrollElement: HTMLElement | undefined | null;\n\n    private eBodyViewport: HTMLElement;\n\n    private scrollLeft = -1;\n    private nextScrollTop = -1;\n    private scrollTop = -1;\n\n    private scrollTimer: number | undefined;\n\n    private readonly resetLastHorizontalScrollElementDebounced: () => void;\n\n    private centerRowContainerCtrl: RowContainerCtrl;\n\n    constructor(eBodyViewport: HTMLElement) {\n        super();\n        this.eBodyViewport = eBodyViewport;\n        this.resetLastHorizontalScrollElementDebounced = debounce(this.resetLastHorizontalScrollElement.bind(this), 500);\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.enableRtl = this.gridOptionsWrapper.isEnableRtl();\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onDisplayedColumnsWidthChanged.bind(this));\n\n        this.ctrlsService.whenReady(p => {\n            this.centerRowContainerCtrl = p.centerRowContainerCtrl;\n            this.onDisplayedColumnsWidthChanged();\n            this.addScrollListener();\n        });\n    }\n\n    private addScrollListener() {\n        const fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n\n        this.addManagedListener(this.centerRowContainerCtrl.getViewportElement(), 'scroll', this.onCenterViewportScroll.bind(this));\n        this.addManagedListener(fakeHScroll.getViewport(), 'scroll', this.onFakeHorizontalScroll.bind(this));\n\n        const onVerticalScroll = this.gridOptionsWrapper.isDebounceVerticalScrollbar() ?\n            debounce(this.onVerticalScroll.bind(this), 100)\n            : this.onVerticalScroll.bind(this);\n\n        this.addManagedListener(this.eBodyViewport, 'scroll', onVerticalScroll);\n    }\n\n    private onDisplayedColumnsWidthChanged(): void {\n        if (this.enableRtl) {\n            // because RTL is all backwards, a change in the width of the row\n            // can cause a change in the scroll position, without a scroll event,\n            // because the scroll position in RTL is a function that depends on\n            // the width. to be convinced of this, take out this line, enable RTL,\n            // scroll all the way to the left and then resize a column\n            this.horizontallyScrollHeaderCenterAndFloatingCenter();\n        }\n    }\n\n    public horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft?: number): void {\n        // when doing RTL, this method gets called once prematurely\n        const notYetInitialised = this.centerRowContainerCtrl == null;\n        if (notYetInitialised) { return; }\n\n        if (scrollLeft === undefined) {\n            scrollLeft = this.centerRowContainerCtrl.getCenterViewportScrollLeft();\n        }\n\n        const offset = this.enableRtl ? scrollLeft : -scrollLeft;\n        const topCenterContainer = this.ctrlsService.getTopCenterRowContainerCtrl();\n        const bottomCenterContainer = this.ctrlsService.getBottomCenterRowContainerCtrl();\n        const fakeHScroll = this.ctrlsService.getFakeHScrollCtrl();\n        const centerHeaderContainer = this.ctrlsService.getHeaderRowContainerCtrl();\n\n        centerHeaderContainer.setHorizontalScroll(offset);\n        bottomCenterContainer.setContainerTranslateX(offset);\n        topCenterContainer.setContainerTranslateX(offset);\n\n        const partner = this.lastHorizontalScrollElement === this.centerRowContainerCtrl.getViewportElement() ?\n                fakeHScroll.getViewport() : this.centerRowContainerCtrl.getViewportElement();\n\n        setScrollLeft(partner, Math.abs(scrollLeft), this.enableRtl);\n    }\n\n    private isControllingScroll(eDiv: HTMLElement): boolean {\n        if (!this.lastHorizontalScrollElement) {\n            this.lastHorizontalScrollElement = eDiv;\n            return true;\n        }\n\n        return eDiv === this.lastHorizontalScrollElement;\n    }\n\n    private onFakeHorizontalScroll(): void {\n        const fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n        if (!this.isControllingScroll(fakeHScrollViewport)) { return; }\n        this.onBodyHorizontalScroll(fakeHScrollViewport);\n    }\n\n    private onCenterViewportScroll(): void {\n        const centerContainerViewport = this.centerRowContainerCtrl.getViewportElement();\n        if (!this.isControllingScroll(centerContainerViewport)) { return; }\n        this.onBodyHorizontalScroll(centerContainerViewport);\n    }\n\n    private onBodyHorizontalScroll(eSource: HTMLElement): void {\n        const centerContainerViewport = this.centerRowContainerCtrl.getViewportElement();\n        const { scrollLeft } = centerContainerViewport;\n\n        if (this.shouldBlockScrollUpdate('horizontal', scrollLeft, true)) {\n            return;\n        }\n\n        // we do Math.round() rather than Math.floor(), to mirror how scroll values are applied.\n        // eg if a scale is applied (ie user has zoomed the browser), then applying scroll=200\n        // could result in 199.88, which then floor(199.88) = 199, however round(199.88) = 200.\n        // initially Math.floor() was used, however this caused (almost) infinite loop with aligned grids,\n        // as the scroll would move 1px at at time bouncing from one grid to the next (eg one grid would cause\n        // scroll to 200px, the next to 199px, then the first back to 198px and so on).\n        this.doHorizontalScroll(Math.round(getScrollLeft(eSource, this.enableRtl)));\n        this.resetLastHorizontalScrollElementDebounced();\n    }\n\n    private onVerticalScroll(): void {\n        const scrollTop: number = this.eBodyViewport.scrollTop;\n\n        if (this.shouldBlockScrollUpdate('vertical', scrollTop, true)) { return; }\n        this.animationFrameService.setScrollTop(scrollTop);\n        this.nextScrollTop = scrollTop;\n\n        if (this.gridOptionsWrapper.isSuppressAnimationFrame()) {\n            this.scrollTop = this.nextScrollTop;\n            this.redrawRowsAfterScroll();\n        } else {\n            this.animationFrameService.schedule();\n        }\n    }\n\n    private resetLastHorizontalScrollElement() {\n        this.lastHorizontalScrollElement = null;\n    }\n\n    private doHorizontalScroll(scrollLeft: number): void {\n        const fakeHScrollViewport = this.ctrlsService.getFakeHScrollCtrl().getViewport();\n        const fakeScrollLeft = getScrollLeft(fakeHScrollViewport, this.enableRtl);\n\n        if (this.scrollLeft === scrollLeft && scrollLeft === fakeScrollLeft) { return; }\n\n        this.scrollLeft = scrollLeft;\n\n        this.fireScrollEvent('horizontal');\n        this.horizontallyScrollHeaderCenterAndFloatingCenter(scrollLeft);\n        this.onHorizontalViewportChanged();\n    }\n\n    private fireScrollEvent(direction: 'horizontal' | 'vertical'): void {\n        const bodyScrollEvent: BodyScrollEvent = {\n            type: Events.EVENT_BODY_SCROLL,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            direction,\n            left: this.scrollLeft,\n            top: this.scrollTop\n        };\n\n        this.eventService.dispatchEvent(bodyScrollEvent);\n\n        window.clearTimeout(this.scrollTimer);\n        this.scrollTimer = undefined;\n\n        this.scrollTimer = window.setTimeout(() => {\n            const bodyScrollEndEvent: BodyScrollEndEvent = Object.assign({}, bodyScrollEvent, {\n                type: Events.EVENT_BODY_SCROLL_END\n            });\n            this.eventService.dispatchEvent(bodyScrollEndEvent);\n        }, 100);\n    }\n\n    private shouldBlockScrollUpdate(direction: ScrollDirection, scrollTo: number, touchOnly: boolean = false): boolean {\n        // touch devices allow elastic scroll - which temporally scrolls the panel outside of the viewport\n        // (eg user uses touch to go to the left of the grid, but drags past the left, the rows will actually\n        // scroll past the left until the user releases the mouse). when this happens, we want ignore the scroll,\n        // as otherwise it was causing the rows and header to flicker.\n\n        // sometimes when scrolling, we got values that extended the maximum scroll allowed. we used to\n        // ignore these scrolls. problem is the max scroll position could be skipped (eg the previous scroll event\n        // could be 10px before the max position, and then current scroll event could be 20px after the max position).\n        // if we just ignored the last event, we would be setting the scroll to 10px before the max position, when in\n        // actual fact the user has exceeded the max scroll and thus scroll should be set to the max.\n\n        if (touchOnly && !isIOSUserAgent()) { return false; }\n\n        if (direction === 'vertical') {\n            const clientHeight = getInnerHeight(this.eBodyViewport);\n            const { scrollHeight } = this.eBodyViewport;\n            if (scrollTo < 0 || (scrollTo + clientHeight > scrollHeight)) {\n                return true;\n            }\n        }\n\n        if (direction === 'horizontal') {\n            const clientWidth = this.centerRowContainerCtrl.getCenterWidth();\n            const { scrollWidth } = this.centerRowContainerCtrl.getViewportElement();\n\n            if (this.enableRtl && isRtlNegativeScroll()) {\n                if (scrollTo > 0) { return true; }\n            } else if (scrollTo < 0) { return true; }\n\n            if (Math.abs(scrollTo) + clientWidth > scrollWidth) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private redrawRowsAfterScroll(): void {\n        this.fireScrollEvent('vertical');\n    }\n\n    private onHorizontalViewportChanged(): void {\n        this.centerRowContainerCtrl.onHorizontalViewportChanged();\n    }\n\n    // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.\n    // (which happens with some implementations of tabbing). this can result in horizontal scroll getting\n    // reset back to the left, however no scroll event is fired. so we need to get header to also scroll\n    // back to the left to be kept in sync.\n    // adding and removing the grid from the DOM both resets the scroll position and\n    // triggers a resize event, so notify listeners if the scroll position has changed\n    public checkScrollLeft(): void {\n        if (this.scrollLeft !== this.centerRowContainerCtrl.getCenterViewportScrollLeft()) {\n            this.onBodyHorizontalScroll(this.centerRowContainerCtrl.getViewportElement());\n        }\n    }\n\n    public executeAnimationFrameScroll(): boolean {\n        const frameNeeded = this.scrollTop != this.nextScrollTop;\n\n        if (frameNeeded) {\n            this.scrollTop = this.nextScrollTop;\n            this.redrawRowsAfterScroll();\n        }\n\n        return frameNeeded;\n    }\n\n    // called by scrollHorizontally method and alignedGridsService\n    public setHorizontalScrollPosition(hScrollPosition: number): void {\n        const minScrollLeft = 0;\n        const maxScrollLeft = this.centerRowContainerCtrl.getViewportElement().scrollWidth - this.centerRowContainerCtrl.getCenterWidth();\n\n        if (this.shouldBlockScrollUpdate('horizontal', hScrollPosition)) {\n            if (this.enableRtl && isRtlNegativeScroll()) {\n                hScrollPosition = hScrollPosition > 0 ? 0 : maxScrollLeft;\n            } else {\n                hScrollPosition = Math.min(Math.max(hScrollPosition, minScrollLeft), maxScrollLeft);\n            }\n        }\n\n        setScrollLeft(this.centerRowContainerCtrl.getViewportElement(), Math.abs(hScrollPosition), this.enableRtl);\n\n        // we need to manually do the event handling (rather than wait for the event)\n        // for the alignedGridsService, as if we don't, the aligned grid service gets\n        // notified async, and then it's 'consuming' flag doesn't get used right, and\n        // we can end up with an infinite loop\n        this.doHorizontalScroll(hScrollPosition);\n    }\n\n    public setVerticalScrollPosition(vScrollPosition: number): void {\n        this.eBodyViewport.scrollTop = vScrollPosition;\n    }\n\n    public getVScrollPosition(): { top: number, bottom: number; } {\n        const result = {\n            top: this.eBodyViewport.scrollTop,\n            bottom: this.eBodyViewport.scrollTop + this.eBodyViewport.offsetHeight\n        };\n        return result;\n    }\n\n    public getHScrollPosition(): { left: number, right: number; } {\n        return this.centerRowContainerCtrl.getHScrollPosition();\n    }\n\n    public isHorizontalScrollShowing(): boolean {\n        return this.centerRowContainerCtrl.isHorizontalScrollShowing();\n    }\n\n    // called by the headerRootComp and moveColumnController\n    public scrollHorizontally(pixels: number): number {\n        const oldScrollPosition = this.centerRowContainerCtrl.getViewportElement().scrollLeft;\n\n        this.setHorizontalScrollPosition(oldScrollPosition + pixels);\n        return this.centerRowContainerCtrl.getViewportElement().scrollLeft - oldScrollPosition;\n    }\n\n    // gets called by rowRenderer when new data loaded, as it will want to scroll to the top\n    public scrollToTop(): void {\n        this.eBodyViewport.scrollTop = 0;\n    }\n\n    // Valid values for position are bottom, middle and top\n    public ensureNodeVisible(comparator: any, position: 'top' | 'bottom' | 'middle' | null = null) {\n\n        // look for the node index we want to display\n        const rowCount = this.rowModel.getRowCount();\n        const comparatorIsAFunction = typeof comparator === 'function';\n        let indexToSelect = -1;\n        // go through all the nodes, find the one we want to show\n        for (let i = 0; i < rowCount; i++) {\n            const node = this.rowModel.getRow(i);\n            if (comparatorIsAFunction) {\n                if (comparator(node)) {\n                    indexToSelect = i;\n                    break;\n                }\n            } else {\n                // check object equality against node and data\n                if (comparator === node || comparator === node!.data) {\n                    indexToSelect = i;\n                    break;\n                }\n            }\n        }\n        if (indexToSelect >= 0) {\n            this.ensureIndexVisible(indexToSelect, position);\n        }\n    }\n\n    // Valid values for position are bottom, middle and top\n    // position should be {'top','middle','bottom', or undefined/null}.\n    // if undefined/null, then the grid will to the minimal amount of scrolling,\n    // eg if grid needs to scroll up, it scrolls until row is on top,\n    //    if grid needs to scroll down, it scrolls until row is on bottom,\n    //    if row is already in view, grid does not scroll\n    public ensureIndexVisible(index: any, position?: 'top' | 'bottom' | 'middle' | null) {\n        // if for print or auto height, everything is always visible\n        if (this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT) { return; }\n\n        const rowCount = this.paginationProxy.getRowCount();\n\n        if (typeof index !== 'number' || index < 0 || index >= rowCount) {\n            console.warn('invalid row index for ensureIndexVisible: ' + index);\n            return;\n        }\n\n        const isPaging = this.gridOptionsWrapper.isPagination();\n        const paginationPanelEnabled = isPaging && !this.gridOptionsWrapper.isSuppressPaginationPanel();\n\n        if (!paginationPanelEnabled) {\n            this.paginationProxy.goToPageWithIndex(index);\n        }\n\n        const rowNode = this.paginationProxy.getRow(index);\n        let rowGotShiftedDuringOperation: boolean;\n\n        do {\n            const startingRowTop = rowNode!.rowTop;\n            const startingRowHeight = rowNode!.rowHeight;\n\n            const paginationOffset = this.paginationProxy.getPixelOffset();\n            const rowTopPixel = rowNode!.rowTop! - paginationOffset;\n            const rowBottomPixel = rowTopPixel + rowNode!.rowHeight!;\n\n            const scrollPosition = this.getVScrollPosition();\n            const heightOffset = this.heightScaler.getDivStretchOffset();\n\n            const vScrollTop = scrollPosition.top + heightOffset;\n            const vScrollBottom = scrollPosition.bottom + heightOffset;\n\n            const viewportHeight = vScrollBottom - vScrollTop;\n\n            // work out the pixels for top, middle and bottom up front,\n            // make the if/else below easier to read\n            const pxTop = this.heightScaler.getScrollPositionForPixel(rowTopPixel);\n            const pxBottom = this.heightScaler.getScrollPositionForPixel(rowBottomPixel - viewportHeight);\n            // make sure if middle, the row is not outside the top of the grid\n            const pxMiddle = Math.min((pxTop + pxBottom) / 2, rowTopPixel);\n\n            const rowBelowViewport = vScrollTop > rowTopPixel;\n            const rowAboveViewport = vScrollBottom < rowBottomPixel;\n\n            let newScrollPosition: number | null = null;\n\n            if (position === 'top') {\n                newScrollPosition = pxTop;\n            } else if (position === 'bottom') {\n                newScrollPosition = pxBottom;\n            } else if (position === 'middle') {\n                newScrollPosition = pxMiddle;\n            } else if (rowBelowViewport) {\n                // if row is before, scroll up with row at top\n                newScrollPosition = pxTop;\n            } else if (rowAboveViewport) {\n                // if row is below, scroll down with row at bottom\n                newScrollPosition = pxBottom;\n            }\n\n            if (newScrollPosition !== null) {\n                this.eBodyViewport.scrollTop = newScrollPosition;\n                this.rowRenderer.redrawAfterScroll();\n            }\n\n            // the row can get shifted if during the rendering (during rowRenderer.redrawAfterScroll()),\n            // the height of a row changes due to lazy calculation of row heights when using\n            // colDef.autoHeight or gridOptions.getRowHeight.\n            // if row was shifted, then the position we scrolled to is incorrect.\n            rowGotShiftedDuringOperation = (startingRowTop !== rowNode!.rowTop)\n                || (startingRowHeight !== rowNode!.rowHeight);\n\n        } while (rowGotShiftedDuringOperation);\n\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    }\n\n    public ensureColumnVisible(key: any, position: 'auto' | 'start' | 'middle' | 'end' = 'auto'): void {\n        const column = this.columnModel.getGridColumn(key);\n\n        if (!column) { return; }\n\n        // calling ensureColumnVisible on a pinned column doesn't make sense\n        if (column.isPinned()) { return; }\n\n        // defensive\n        if (!this.columnModel.isColumnDisplayed(column)) { return; }\n\n        const newHorizontalScroll: number | null = this.getPositionedHorizontalScroll(column, position);\n\n        if (newHorizontalScroll !== null) {\n            this.centerRowContainerCtrl.setCenterViewportScrollLeft(newHorizontalScroll);\n        }\n\n        // this will happen anyway, as the move will cause a 'scroll' event on the body, however\n        // it is possible that the ensureColumnVisible method is called from within AG Grid and\n        // the caller will need to have the columns rendered to continue, which will be before\n        // the event has been worked on (which is the case for cell navigation).\n        this.centerRowContainerCtrl.onHorizontalViewportChanged();\n\n        // so when we return back to user, the cells have rendered\n        this.animationFrameService.flushAllFrames();\n    }\n\n    private getPositionedHorizontalScroll(column: Column, position: 'auto' | 'start' | 'middle' | 'end'): number | null {\n        const { columnBeforeStart, columnAfterEnd } = this.isColumnOutsideViewport(column);\n\n        const viewportTooSmallForColumn = this.centerRowContainerCtrl.getCenterWidth() < column.getActualWidth();\n        const viewportWidth = this.centerRowContainerCtrl.getCenterWidth();\n\n        const isRtl = this.enableRtl;\n\n        let alignColToStart = (isRtl ? columnBeforeStart : columnAfterEnd) || viewportTooSmallForColumn;\n        let alignColToEnd = isRtl ? columnAfterEnd : columnBeforeStart;\n\n        if (position !== 'auto') {\n            alignColToStart = position === 'start';\n            alignColToEnd = position === 'end';\n        }\n\n        const isMiddle = position === 'middle';\n\n        if (alignColToStart || alignColToEnd || isMiddle) {\n            const { colLeft, colMiddle, colRight } = this.getColumnBounds(column);\n\n            if (isMiddle) {\n                return colMiddle - viewportWidth / 2;\n            }\n\n            if (alignColToStart) {\n                return isRtl ?  colRight : colLeft;\n            }\n\n            return isRtl ? (colLeft - viewportWidth) : (colRight - viewportWidth);\n        }\n\n        return null;\n    }\n\n    private isColumnOutsideViewport(column: Column): { columnBeforeStart: boolean, columnAfterEnd: boolean } {\n        const { start: viewportStart, end: viewportEnd } = this.getViewportBounds();\n        const { colLeft, colRight } = this.getColumnBounds(column);\n\n        const isRtl = this.enableRtl;\n\n        const columnBeforeStart = isRtl ? (viewportStart > colRight) : (viewportEnd < colRight);\n        const columnAfterEnd = isRtl ? (viewportEnd < colLeft) : (viewportStart > colLeft);\n\n        return { columnBeforeStart, columnAfterEnd };\n    }\n\n    private getColumnBounds(column: Column): { colLeft: number, colMiddle: number, colRight: number } {\n        const isRtl = this.enableRtl;\n        const bodyWidth = this.columnModel.getBodyContainerWidth();\n        const colWidth = column.getActualWidth();\n        const colLeft = column.getLeft()!;\n        const multiplier = isRtl ? -1 : 1;\n\n        const colLeftPixel = isRtl ? (bodyWidth - colLeft) : colLeft;\n        const colRightPixel = colLeftPixel + colWidth * multiplier;\n        const colMidPixel = colLeftPixel + colWidth / 2 * multiplier;\n\n        return { colLeft: colLeftPixel, colMiddle: colMidPixel, colRight: colRightPixel };\n    }\n\n    private getViewportBounds(): { start: number, end: number, width: number } {\n        const viewportWidth = this.centerRowContainerCtrl.getCenterWidth();\n        const scrollPosition = this.centerRowContainerCtrl.getCenterViewportScrollLeft();\n\n        const viewportStartPixel = scrollPosition;\n        const viewportEndPixel = viewportWidth + scrollPosition;\n\n        return { start: viewportStartPixel, end: viewportEndPixel, width: viewportWidth };\n    }\n}"]}