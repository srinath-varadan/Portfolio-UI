{"version":3,"sources":["../../../src/ts/rendering/autoWidthCalculator.ts"],"names":[],"mappings":"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","file":"autoWidthCalculator.js","sourcesContent":["import { RowRenderer } from \"./rowRenderer\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { CtrlsService } from \"../ctrlsService\";\nimport { RowContainerCtrl } from \"../gridBodyComp/rowContainer/rowContainerCtrl\";\nimport { RowCssClassCalculator } from \"./row/rowCssClassCalculator\";\nimport { ColumnGroup } from \"../entities/columnGroup\";\n\n@Bean('autoWidthCalculator')\nexport class AutoWidthCalculator extends BeanStub {\n\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('ctrlsService') private ctrlsService: CtrlsService;\n    @Autowired('rowCssClassCalculator') public rowCssClassCalculator: RowCssClassCalculator;\n\n    private centerRowContainerCtrl: RowContainerCtrl;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(p => {\n            this.centerRowContainerCtrl = p.centerRowContainerCtrl;\n        });\n    }\n\n    // this is the trick: we create a dummy container and clone all the cells\n    // into the dummy, then check the dummy's width. then destroy the dummy\n    // as we don't need it any more.\n    // drawback: only the cells visible on the screen are considered\n    public getPreferredWidthForColumn(column: Column, skipHeader?: boolean): number {\n        const eHeaderCell = this.getHeaderCellForColumn(column);\n        // cell isn't visible\n        if (!eHeaderCell) { return -1; }\n\n        const elements = this.rowRenderer.getAllCellsForColumn(column);\n\n        if (!skipHeader) {\n            // we only consider the lowest level cell, not the group cell. in 99% of the time, this\n            // will be enough. if we consider groups, then it gets too complicated for what it's worth,\n            // as the groups can span columns and this class only considers one column at a time.\n            elements.push(eHeaderCell);\n        }\n\n        return this.addElementsToContainerAndGetWidth(elements);\n    }\n\n    public getPreferredWidthForColumnGroup(columnGroup: ColumnGroup): number {\n        const eHeaderCell = this.getHeaderCellForColumn(columnGroup);\n\n        if (!eHeaderCell) { return -1; }\n\n        return this.addElementsToContainerAndGetWidth([eHeaderCell]);\n    }\n\n    private addElementsToContainerAndGetWidth(elements: HTMLElement[]): number {\n        const eDummyContainer = document.createElement('span');\n        // position fixed, so it isn't restricted to the boundaries of the parent\n        eDummyContainer.style.position = 'fixed';\n\n        // we put the dummy into the body container, so it will inherit all the\n        // css styles that the real cells are inheriting\n        const eBodyContainer = this.centerRowContainerCtrl.getContainerElement();\n        eBodyContainer.appendChild(eDummyContainer);\n\n        elements.forEach(el => this.cloneItemIntoDummy(el, eDummyContainer));\n\n        // at this point, all the clones are lined up vertically with natural widths. the dummy\n        // container will have a width wide enough just to fit the largest.\n        const dummyContainerWidth = eDummyContainer.offsetWidth;\n\n        // we are finished with the dummy container, so get rid of it\n        eBodyContainer.removeChild(eDummyContainer);\n\n        // we add padding as I found sometimes the gui still put '...' after some of the texts. so the\n        // user can configure the grid to add a few more pixels after the calculated width\n        const autoSizePadding = this.gridOptionsWrapper.getAutoSizePadding();\n\n        return dummyContainerWidth + autoSizePadding;\n    }\n\n    /* tslint:disable */\n    private getHeaderCellForColumn(column: ColumnGroup): HTMLElement | null;\n    private getHeaderCellForColumn(column: Column): HTMLElement | null;\n    private getHeaderCellForColumn(column: any): any {\n    /* tslint:enable */\n        let element: HTMLElement | null = null;\n\n        this.ctrlsService.getHeaderRowContainerCtrls().forEach(container => {\n                const res = container.getHtmlElementForColumnHeader(column);\n                if (res != null) { element = res; }\n            }\n        );\n\n        return element;\n    }\n\n    private cloneItemIntoDummy(eCell: HTMLElement, eDummyContainer: HTMLElement): void {\n        // make a deep clone of the cell\n        const eCellClone: HTMLElement = eCell.cloneNode(true) as HTMLElement;\n        // the original has a fixed width, we remove this to allow the natural width based on content\n        eCellClone.style.width = '';\n        // the original has position = absolute, we need to remove this so it's positioned normally\n        eCellClone.style.position = 'static';\n        eCellClone.style.left = '';\n        // we put the cell into a containing div, as otherwise the cells would just line up\n        // on the same line, standard flow layout, by putting them into divs, they are laid\n        // out one per line\n        const eCloneParent = document.createElement('div');\n        const eCloneParentClassList = eCloneParent.classList;\n        const isHeader = ['ag-header-cell', 'ag-header-group-cell'].some(\n            cls => eCellClone.classList.contains(cls)\n        );\n\n        if (isHeader) {\n            eCloneParentClassList.add('ag-header', 'ag-header-row');\n            eCloneParent.style.position = 'static';\n        } else {\n            eCloneParentClassList.add('ag-row');\n        }\n\n        // find parent using classes (headers have ag-header-cell, rows have ag-row), and copy classes from it.\n        // if we didn't do this, things like ag-row-level-2 would be missing if present, which sets indents\n        // onto group items.\n        let pointer = eCell.parentElement;\n        while (pointer) {\n            const isRow = ['ag-header-row', 'ag-row'].some(\n                cls => pointer!.classList.contains(cls)\n            );\n            if (isRow) {\n                for (let i = 0; i < pointer.classList.length; i++) {\n                    const item = pointer.classList[i];\n\n                    // we skip ag-row-position-absolute, as this has structural CSS applied that stops the\n                    // element from fitting into it's parent, and we need the element to stretch the parent\n                    // as we are measuring the parents width\n                    if (item != 'ag-row-position-absolute') {\n                        eCloneParentClassList.add(item);\n                    }\n                }\n                break;\n            }\n            pointer = pointer.parentElement;\n        }\n\n        // the twig on the branch, the branch on the tree, the tree in the hole,\n        // the hole in the bog, the bog in the clone, the clone in the parent,\n        // the parent in the dummy, and the dummy down in the vall-e-ooo, OOOOOOOOO! Oh row the rattling bog....\n        eCloneParent.appendChild(eCellClone);\n        eDummyContainer.appendChild(eCloneParent);\n    }\n}\n"]}