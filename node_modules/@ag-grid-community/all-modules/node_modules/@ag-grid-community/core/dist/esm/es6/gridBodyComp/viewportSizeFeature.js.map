{"version":3,"sources":["../../../src/ts/gridBodyComp/viewportSizeFeature.ts"],"names":[],"mappings":"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","file":"viewportSizeFeature.js","sourcesContent":["import { BeanStub } from \"../context/beanStub\";\nimport { Autowired, PostConstruct } from \"../context/context\";\nimport { ColumnModel } from \"../columns/columnModel\";\nimport { ScrollVisibleService, SetScrollsVisibleParams } from \"../gridBodyComp/scrollVisibleService\";\nimport { GridBodyCtrl } from \"./gridBodyCtrl\";\nimport { BodyHeightChangedEvent, Events } from \"../events\";\nimport { ColumnApi } from \"../columns/columnApi\";\nimport { GridApi } from \"../gridApi\";\nimport { CtrlsService } from \"../ctrlsService\";\nimport { RowContainerCtrl } from \"./rowContainer/rowContainerCtrl\";\nimport { getInnerHeight } from \"../utils/dom\";\n\n// listens to changes in the center viewport size, for column and row virtualisation,\n// and adjusts grid as necessary. there are two viewports, one for horizontal and one for\n// vertical scrolling.\nexport class ViewportSizeFeature extends BeanStub {\n\n    @Autowired('ctrlsService') private ctrlsService: CtrlsService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('scrollVisibleService') private scrollVisibleService: ScrollVisibleService;\n    @Autowired('columnApi') private columnApi: ColumnApi;\n    @Autowired('gridApi') private gridApi: GridApi;\n\n    private centerContainerCtrl: RowContainerCtrl;\n    private gridBodyCtrl: GridBodyCtrl;\n\n    private centerWidth: number;\n    private bodyHeight: number;\n\n    constructor(centerContainerCtrl: RowContainerCtrl) {\n        super();\n        this.centerContainerCtrl = centerContainerCtrl;\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(() => {\n            this.gridBodyCtrl = this.ctrlsService.getGridBodyCtrl();\n            this.listenForResize();\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_SCROLLBAR_WIDTH_CHANGED, this.onScrollbarWidthChanged.bind(this));\n    }\n\n    private listenForResize(): void {\n        const listener = ()=> this.onCenterViewportResized();\n\n        // centerContainer gets horizontal resizes\n        this.centerContainerCtrl.registerViewportResizeListener(listener);\n\n        // eBodyViewport gets vertical resizes\n        this.gridBodyCtrl.registerBodyViewportResizeListener(listener);\n    }\n\n    private onScrollbarWidthChanged() {\n        this.checkViewportAndScrolls();\n    }\n\n    private onCenterViewportResized(): void {\n        if (this.centerContainerCtrl.isViewportVisible()) {\n            this.checkViewportAndScrolls();\n\n            const newWidth = this.centerContainerCtrl.getCenterWidth();\n\n            if (newWidth !== this.centerWidth) {\n                this.centerWidth = newWidth;\n                this.columnModel.refreshFlexedColumns(\n                    { viewportWidth: this.centerWidth, updateBodyWidths: true, fireResizedEvent: true }\n                );\n            }\n        } else {\n            this.bodyHeight = 0;\n        }\n    }\n\n    // gets called every time the viewport size changes. we use this to check visibility of scrollbars\n    // in the grid panel, and also to check size and position of viewport for row and column virtualisation.\n    private checkViewportAndScrolls(): void {\n        // results in updating anything that depends on scroll showing\n        this.updateScrollVisibleService();\n\n        // fires event if height changes, used by PaginationService, HeightScalerService, RowRenderer\n        this.checkBodyHeight();\n\n        // check for virtual columns for ColumnController\n        this.onHorizontalViewportChanged();\n\n        this.gridBodyCtrl.getScrollFeature().checkScrollLeft();\n    }\n\n    public getBodyHeight(): number {\n        return this.bodyHeight;\n    }\n\n    private checkBodyHeight(): void {\n        const eBodyViewport = this.gridBodyCtrl.getBodyViewportElement();\n        const bodyHeight = getInnerHeight(eBodyViewport);\n\n        if (this.bodyHeight !== bodyHeight) {\n            this.bodyHeight = bodyHeight;\n            const event: BodyHeightChangedEvent = {\n                type: Events.EVENT_BODY_HEIGHT_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    private updateScrollVisibleService(): void {\n        // because of column animation (which takes 200ms), we have to do this twice.\n        // eg if user removes cols anywhere except at the RHS, then the cols on the RHS\n        // will animate to the left to fill the gap. this animation means just after\n        // the cols are removed, the remaining cols are still in the original location\n        // at the start of the animation, so pre animation the H scrollbar is still needed,\n        // but post animation it is not.\n        this.updateScrollVisibleServiceImpl();\n        setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);\n    }\n\n    private updateScrollVisibleServiceImpl(): void {\n        const params: SetScrollsVisibleParams = {\n            horizontalScrollShowing: this.isHorizontalScrollShowing(),\n            verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()\n        };\n\n        this.scrollVisibleService.setScrollsVisible(params);\n\n        // fix - gridComp should just listen to event from above\n        this.gridBodyCtrl.setVerticalScrollPaddingVisible(params.verticalScrollShowing);\n    }\n\n    private isHorizontalScrollShowing(): boolean {\n        const isAlwaysShowHorizontalScroll = this.gridOptionsWrapper.isAlwaysShowHorizontalScroll();\n        return isAlwaysShowHorizontalScroll || this.centerContainerCtrl.isViewportHScrollShowing();\n    }\n\n    // this gets called whenever a change in the viewport, so we can inform column controller it has to work\n    // out the virtual columns again. gets called from following locations:\n    // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged, API (doLayout)\n    private onHorizontalViewportChanged(): void {\n        const scrollWidth = this.centerContainerCtrl.getCenterWidth();\n        const scrollPosition = this.centerContainerCtrl.getViewportScrollLeft();\n\n        this.columnModel.setViewportPosition(scrollWidth, scrollPosition);\n    }\n}"]}