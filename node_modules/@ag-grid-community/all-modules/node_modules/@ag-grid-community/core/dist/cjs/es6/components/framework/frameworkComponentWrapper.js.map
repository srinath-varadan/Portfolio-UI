{"version":3,"sources":["../../../src/ts/components/framework/frameworkComponentWrapper.ts"],"names":[],"mappings":";;;;;;;;AAuBA,MAAsB,oBAAoB;IAC/B,IAAI,CAA4B,mBAAmC,EAC1C,mBAA6B,EAC7B,qBAA+B,EAAE,EACjC,aAA4B;QACxD,MAAM,OAAO,GAAM,IAAI,CAAC,aAAa,CAAC,mBAAmB,EAAE,aAAa,CAAC,CAAC;QAE1E,mBAAmB,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC,EAAE;YACtC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC,CAAC;QAEJ,kBAAkB,CAAC,OAAO,CAAC,CAAC,UAAU,CAAC,EAAE;YACrC,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC,CAAC;QAEJ,OAAO,OAAmB,CAAC;IAE/B,CAAC;IAEM,MAAM,CAAC,IAAS;QACnB,OAAO,IAAI,CAAC;IAChB,CAAC;IAIO,YAAY,CAAC,OAAU,EAAE,UAAkB,EAAE,SAAkB;QACnE,OAAO,CAAC,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE,UAAU,EAAE,SAAS,CAAC,CAAC,CAAC;IAC1F,CAAC;IAES,iBAAiB,CAAC,OAAU,EAAE,UAAkB,EAAE,SAAkB;QAC1E,OAAO;YACH,IAAI,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE;gBAC/B,OAAO,OAAO,CAAC,UAAU,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;aACpD;YAED,IAAI,SAAS,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,qDAAqD,GAAG,UAAU,GAAG,IAAI,CAAC,CAAC;aAC3F;YACD,OAAO,IAAI,CAAC;QAChB,CAAC,CAAC;IACN,CAAC;CACJ;AAzCD,oDAyCC","file":"frameworkComponentWrapper.js","sourcesContent":["import { IComponent } from \"../../interfaces/iComponent\";\nimport { ComponentType } from \"./componentTypes\";\n\n/**\n * B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid\n */\nexport interface FrameworkComponentWrapper {\n    wrap<A extends IComponent<any>>(frameworkComponent: { new(): any } | null,\n                                    methodList: string[],\n                                    optionalMethodList: string[],\n                                    componentType: ComponentType\n    ): A;\n}\n\nexport interface WrappableInterface {\n    hasMethod(name: string): boolean;\n\n    callMethod(name: string, args: IArguments): void;\n\n    addMethod(name: string, callback: Function): void;\n}\n\nexport abstract class BaseComponentWrapper<F extends WrappableInterface> implements FrameworkComponentWrapper {\n    public wrap<A extends IComponent<any>>(OriginalConstructor: { new(): any },\n                                    mandatoryMethodList: string[],\n                                    optionalMethodList: string[] = [],\n                                    componentType: ComponentType): A {\n        const wrapper: F = this.createWrapper(OriginalConstructor, componentType);\n\n        mandatoryMethodList.forEach((methodName => {\n            this.createMethod(wrapper, methodName, true);\n        }));\n\n        optionalMethodList.forEach((methodName => {\n            this.createMethod(wrapper, methodName, false);\n        }));\n\n        return wrapper as any as A;\n\n    }\n\n    public unwrap(comp: any): any {\n        return comp;\n    }\n\n    abstract createWrapper(OriginalConstructor: { new(): any }, componentType: ComponentType): F;\n\n    private createMethod(wrapper: F, methodName: string, mandatory: boolean): void {\n        wrapper.addMethod(methodName, this.createMethodProxy(wrapper, methodName, mandatory));\n    }\n\n    protected createMethodProxy(wrapper: F, methodName: string, mandatory: boolean): Function {\n        return function() {\n            if (wrapper.hasMethod(methodName)) {\n                return wrapper.callMethod(methodName, arguments);\n            }\n\n            if (mandatory) {\n                console.warn('AG Grid: Framework component is missing the method ' + methodName + '()');\n            }\n            return null;\n        };\n    }\n}\n"]}