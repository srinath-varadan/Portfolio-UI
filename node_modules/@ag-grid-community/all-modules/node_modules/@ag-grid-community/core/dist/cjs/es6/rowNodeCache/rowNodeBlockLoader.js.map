{"version":3,"sources":["../../../src/ts/rowNodeCache/rowNodeBlockLoader.ts"],"names":[],"mappings":"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","file":"rowNodeBlockLoader.js","sourcesContent":["import { RowNodeBlock } from \"./rowNodeBlock\";\nimport { Bean, PostConstruct, Qualifier } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { Logger, LoggerFactory } from \"../logger\";\nimport { _ } from \"../utils\";\n\n@Bean('rowNodeBlockLoader')\nexport class RowNodeBlockLoader extends BeanStub {\n\n    public static BLOCK_LOADER_FINISHED_EVENT = 'blockLoaderFinished';\n\n    private maxConcurrentRequests: number | undefined;\n    private checkBlockToLoadDebounce: () => void;\n\n    private activeBlockLoadsCount = 0;\n    private blocks: RowNodeBlock[] = [];\n    private logger: Logger;\n    private active = true;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.maxConcurrentRequests = this.gridOptionsWrapper.getMaxConcurrentDatasourceRequests();\n        const blockLoadDebounceMillis = this.gridOptionsWrapper.getBlockLoadDebounceMillis();\n\n        if (blockLoadDebounceMillis && blockLoadDebounceMillis > 0) {\n            this.checkBlockToLoadDebounce = _.debounce(this.performCheckBlocksToLoad.bind(this), blockLoadDebounceMillis);\n        }\n    }\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('RowNodeBlockLoader');\n    }\n\n    public addBlock(block: RowNodeBlock): void {\n        this.blocks.push(block);\n\n        // note that we do not remove this listener when removing the block. this is because the\n        // cache can get destroyed (and containing blocks) when a block is loading. however the loading block\n        // is still counted as an active loading block and we must decrement activeBlockLoadsCount when it finishes.\n        block.addEventListener(RowNodeBlock.EVENT_LOAD_COMPLETE, this.loadComplete.bind(this));\n\n        this.checkBlockToLoad();\n    }\n\n    public removeBlock(block: RowNodeBlock): void {\n        _.removeFromArray(this.blocks, block);\n    }\n\n    protected destroy(): void {\n        super.destroy();\n        this.active = false;\n    }\n\n    private loadComplete(): void {\n        this.activeBlockLoadsCount--;\n        this.checkBlockToLoad();\n        if (this.activeBlockLoadsCount == 0) {\n            this.dispatchEvent({type: RowNodeBlockLoader.BLOCK_LOADER_FINISHED_EVENT});\n        }\n    }\n\n    public checkBlockToLoad(): void {\n        if (this.checkBlockToLoadDebounce) {\n            this.checkBlockToLoadDebounce();\n        } else {\n            this.performCheckBlocksToLoad();\n        }\n    }\n\n    private performCheckBlocksToLoad(): void {\n        if (!this.active) { return; }\n\n        this.printCacheStatus();\n\n        if (this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {\n            this.logger.log(`checkBlockToLoad: max loads exceeded`);\n            return;\n        }\n\n        let blockToLoad: RowNodeBlock | null = null;\n        this.blocks.forEach(block => {\n            if (block.getState() === RowNodeBlock.STATE_WAITING_TO_LOAD) {\n                blockToLoad = block;\n            }\n        });\n\n        if (blockToLoad) {\n            (blockToLoad as RowNodeBlock).load();\n            this.activeBlockLoadsCount++;\n            this.printCacheStatus();\n        }\n    }\n\n    public getBlockState(): any {\n        const result: any = {};\n        this.blocks.forEach((block: RowNodeBlock) => {\n            const {id, state} = block.getBlockStateJson();\n            result[id] = state;\n        });\n        return result;\n    }\n\n    private printCacheStatus(): void {\n\n        if (this.logger.isLogging()) {\n            this.logger.log(`printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount},`\n                + ` blocks = ${JSON.stringify(this.getBlockState())}`);\n        }\n    }\n\n    public isLoading(): boolean {\n        return this.activeBlockLoadsCount > 0;\n    }\n}\n"]}