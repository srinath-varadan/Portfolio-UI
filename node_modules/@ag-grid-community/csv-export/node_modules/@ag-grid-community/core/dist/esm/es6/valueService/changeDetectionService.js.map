{"version":3,"sources":["../../../src/ts/valueService/changeDetectionService.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,qBAAqB,CAAC;AAG/C,OAAO,EAAE,SAAS,EAAE,IAAI,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAC;AACpE,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAGnD,OAAO,EAAE,SAAS,EAAE,MAAM,wBAAwB,CAAC;AACnD,OAAO,EAAyB,MAAM,EAAE,MAAM,WAAW,CAAC;AAI1D,IAAa,sBAAsB,GAAnC,MAAa,sBAAuB,SAAQ,QAAQ;IAQxC,IAAI;QACR,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,SAAS,CAAC,0BAA0B,EAAE;YAClE,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,QAA+B,CAAC;SAClE;QAED,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,MAAM,CAAC,wBAAwB,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACpH,CAAC;IAEO,kBAAkB,CAAC,KAA4B;QAEnD,gFAAgF;QAChF,mFAAmF;QACnF,4FAA4F;QAC5F,4FAA4F;QAC5F,wFAAwF;QACxF,8BAA8B;QAC9B,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS,CAAC,YAAY,EAAE;YAAE,OAAO;SAAE;QAExD,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;IACrD,CAAC;IAEO,iBAAiB,CAAC,OAAgB,EAAE,MAAc;QACtD,IAAI,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,EAAE;YAAE,OAAO;SAAE;QAEpE,gEAAgE;QAChE,IAAI,IAAI,CAAC,kBAAkB,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;YACnD,MAAM,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,CAAC,6BAA6B,EAAE,CAAC;YACnF,MAAM,WAAW,GAAG,IAAI,WAAW,CAAC,kBAAkB,EAAE,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,CAAC,CAAC;YAC/F,WAAW,CAAC,aAAa,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;YACpD,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;SACpD;QAED,qDAAqD;QACrD,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE,CAAC;IACpC,CAAC;CACJ,CAAA;AAzC0B;IAAtB,SAAS,CAAC,UAAU,CAAC;wDAA6B;AACzB;IAAzB,SAAS,CAAC,aAAa,CAAC;2DAAkC;AAK3D;IADC,aAAa;kDAOb;AAdQ,sBAAsB;IADlC,IAAI,CAAC,wBAAwB,CAAC;GAClB,sBAAsB,CA2ClC;SA3CY,sBAAsB","file":"changeDetectionService.js","sourcesContent":["import { BeanStub } from \"../context/beanStub\";\nimport { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { ChangedPath } from \"../utils/changedPath\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { RowRenderer } from \"../rendering/rowRenderer\";\nimport { Constants } from \"../constants/constants\";\nimport { CellValueChangedEvent, Events } from \"../events\";\nimport { IClientSideRowModel } from \"../interfaces/iClientSideRowModel\";\n\n@Bean('changeDetectionService')\nexport class ChangeDetectionService extends BeanStub {\n\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n\n    private clientSideRowModel: IClientSideRowModel;\n\n    @PostConstruct\n    private init(): void {\n        if (this.rowModel.getType() === Constants.ROW_MODEL_TYPE_CLIENT_SIDE) {\n            this.clientSideRowModel = this.rowModel as IClientSideRowModel;\n        }\n\n        this.addManagedListener(this.eventService, Events.EVENT_CELL_VALUE_CHANGED, this.onCellValueChanged.bind(this));\n    }\n\n    private onCellValueChanged(event: CellValueChangedEvent): void {\n\n        // Clipboard service manages its own change detection, so no need to do it here.\n        // The clipboard manages its own as otherwise this would happen once for every cell\n        // that got updated as part of a paste operation, so e.g. if 100 cells in a paste operation,\n        // this doChangeDetection would get called 100 times (once for each cell), instead clipboard\n        // service executes the logic we have here once (in essence batching up all cell changes\n        // into one change detection).\n        if (event.source === Constants.SOURCE_PASTE) { return; }\n\n        this.doChangeDetection(event.node, event.column);\n    }\n\n    private doChangeDetection(rowNode: RowNode, column: Column): void {\n        if (this.gridOptionsWrapper.isSuppressChangeDetection()) { return; }\n\n        // step 1 of change detection is to update the aggregated values\n        if (this.clientSideRowModel && !rowNode.isRowPinned()) {\n            const onlyChangedColumns = this.gridOptionsWrapper.isAggregateOnlyChangedColumns();\n            const changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n            changedPath.addParentNode(rowNode.parent, [column]);\n            this.clientSideRowModel.doAggregate(changedPath);\n        }\n\n        // step 2 of change detection is to refresh the cells\n        this.rowRenderer.refreshCells();\n    }\n}\n"]}