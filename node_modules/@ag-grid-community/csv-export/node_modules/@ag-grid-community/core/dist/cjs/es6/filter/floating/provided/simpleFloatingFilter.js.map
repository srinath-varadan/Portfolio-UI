{"version":3,"sources":["../../../src/ts/filter/floating/provided/simpleFloatingFilter.ts"],"names":[],"mappings":"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","file":"simpleFloatingFilter.js","sourcesContent":["import { Component } from '../../../widgets/component';\nimport { IFloatingFilterComp, IFloatingFilterParams } from '../floatingFilter';\nimport { IFilterOptionDef, ProvidedFilterModel } from '../../../interfaces/iFilter';\nimport { ICombinedSimpleModel, ISimpleFilter, ISimpleFilterModel, SimpleFilter } from '../../provided/simpleFilter';\nimport { OptionsFactory } from '../../provided/optionsFactory';\nimport { IScalarFilterParams } from '../../provided/scalarFilter';\nimport { FilterChangedEvent } from '../../../events';\nimport { IProvidedFilterParams } from '../../provided/providedFilter';\n\nexport abstract class SimpleFloatingFilter extends Component implements IFloatingFilterComp<ISimpleFilter> {\n\n    // this method is on IFloatingFilterComp. because it's not implemented at this level, we have to\n    // define it as an abstract method. it gets implemented in sub classes.\n    public abstract onParentModelChanged(model: ProvidedFilterModel, event: FilterChangedEvent): void;\n\n    // creates text equivalent of FilterModel. if it's a combined model, this takes just one condition.\n    protected abstract conditionToString(condition: ProvidedFilterModel, opts?: IFilterOptionDef): string;\n    protected abstract getDefaultFilterOptions(): string[];\n    protected abstract setEditable(editable: boolean): void;\n\n    private lastType: string | null | undefined;\n\n    private optionsFactory: OptionsFactory;\n\n    private readOnly: boolean;\n\n    protected getDefaultDebounceMs(): number {\n        return 0;\n    }\n\n    // this is a user component, and IComponent has \"public destroy()\" as part of the interface.\n    // so we need to override destroy() just to make the method public.\n    public destroy(): void {\n        super.destroy();\n    }\n\n    // used by:\n    // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.\n    // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)\n    protected getTextFromModel(model: ProvidedFilterModel): string | null {\n        if (!model) { return null; }\n\n        const isCombined = (model as any).operator != null;\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n            const { condition1, condition2 } = combinedModel || {};\n            const customOption1 = this.optionsFactory.getCustomOption(condition1.type);\n            const customOption2 = this.optionsFactory.getCustomOption(condition2.type);\n\n            return [\n                this.conditionToString(condition1, customOption1),\n                combinedModel.operator,\n                this.conditionToString(condition2, customOption2),\n            ].join(' ');\n        } else {\n            const condition = model as ISimpleFilterModel;\n            const customOption = this.optionsFactory.getCustomOption(condition.type);\n\n            // For custom filter options we display the Name of the filter instead\n            // of displaying the `from` value, as it wouldn't be relevant\n            const { displayKey, displayName, numberOfInputs } = customOption || {};\n            if (displayKey && displayName && numberOfInputs === 0) {\n                this.gridOptionsWrapper.getLocaleTextFunc()(displayKey, displayName);\n                return displayName;\n            }\n            return this.conditionToString(condition, customOption);\n        }\n    }\n\n    protected isEventFromFloatingFilter(event: FilterChangedEvent): boolean | undefined {\n        return event && event.afterFloatingFilter;\n    }\n\n    protected getLastType(): string | null | undefined {\n        return this.lastType;\n    }\n\n    protected isReadOnly(): boolean {\n        return this.readOnly;\n    }\n\n    protected setLastTypeFromModel(model: ProvidedFilterModel): void {\n        // if no model provided by the parent filter use default\n        if (!model) {\n            this.lastType = this.optionsFactory.getDefaultOption();\n            return;\n        }\n\n        const isCombined = (model as any).operator;\n\n        let condition: ISimpleFilterModel;\n\n        if (isCombined) {\n            const combinedModel = model as ICombinedSimpleModel<ISimpleFilterModel>;\n            condition = combinedModel.condition1;\n        } else {\n            condition = model as ISimpleFilterModel;\n        }\n\n        this.lastType = condition.type;\n    }\n\n    protected canWeEditAfterModelFromParentFilter(model: ProvidedFilterModel): boolean {\n        if (!model) {\n            // if no model, then we can edit as long as the lastType is something we can edit, as this\n            // is the type we will provide to the parent filter if the user decides to use the floating filter.\n            return this.isTypeEditable(this.lastType);\n        }\n\n        // never allow editing if the filter is combined (ie has two parts)\n        const isCombined = (model as any).operator;\n\n        if (isCombined) {\n            return false;\n        }\n\n        const simpleModel = model as ISimpleFilterModel;\n\n        return this.isTypeEditable(simpleModel.type);\n    }\n\n    public init(params: IFloatingFilterParams): void {\n        this.optionsFactory = new OptionsFactory();\n        this.optionsFactory.init(params.filterParams as IScalarFilterParams, this.getDefaultFilterOptions());\n        this.lastType = this.optionsFactory.getDefaultOption();\n\n        // readOnly is a property of IProvidedFilterParams - we need to find a better (type-safe)\n        // way to support reading this in the future.\n        this.readOnly = !!(params.filterParams as IProvidedFilterParams).readOnly;\n\n        // we are editable if:\n        // 1) there is a type (user has configured filter wrong if not type)\n        //  AND\n        // 2) the default type is not 'in range'\n        const editable = this.isTypeEditable(this.lastType);\n        this.setEditable(editable);\n    }\n\n    private doesFilterHaveSingleInput(filterType: string) {\n        const customFilterOption = this.optionsFactory.getCustomOption(filterType);\n        const { numberOfInputs } = customFilterOption || {};\n        return numberOfInputs == null || numberOfInputs == 1;\n    }\n\n    private isTypeEditable(type?: string | null): boolean {\n        const uneditableTypes: string[] = [\n            SimpleFilter.IN_RANGE, SimpleFilter.EMPTY, SimpleFilter.BLANK, SimpleFilter.NOT_BLANK,\n        ];\n        return !!type &&\n            !this.isReadOnly() &&\n            this.doesFilterHaveSingleInput(type) &&\n            uneditableTypes.indexOf(type) < 0;\n    }\n}\n"]}