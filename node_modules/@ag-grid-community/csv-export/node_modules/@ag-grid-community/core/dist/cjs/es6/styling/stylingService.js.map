{"version":3,"sources":["../../../src/ts/styling/stylingService.ts"],"names":[],"mappings":"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","file":"stylingService.js","sourcesContent":["import { CellClassParams, ColDef } from \"../entities/colDef\";\nimport { Autowired, Bean } from \"../context/context\";\nimport { ExpressionService } from \"../valueService/expressionService\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { RowClassParams } from \"../entities/gridOptions\";\n\n@Bean('stylingService')\nexport class StylingService extends BeanStub {\n\n    @Autowired('expressionService') private expressionService: ExpressionService;\n\n    public processAllCellClasses(\n        colDef: ColDef,\n        params: CellClassParams,\n        onApplicableClass: (className: string) => void,\n        onNotApplicableClass?: (className: string) => void\n    ) {\n        this.processClassRules(colDef.cellClassRules, params, onApplicableClass, onNotApplicableClass);\n        this.processStaticCellClasses(colDef, params, onApplicableClass);\n    }\n\n    public processClassRules(\n        classRules: { [cssClassName: string]: (Function | string) } | undefined,\n        params: RowClassParams | CellClassParams,\n        onApplicableClass: (className: string) => void,\n        onNotApplicableClass?: (className: string) => void\n    ) {\n        if (classRules == null)  { return; }\n\n        const classNames = Object.keys(classRules!);\n        const classesToApply: {[name: string]: boolean} = {};\n        const classesToRemove: {[name: string]: boolean} = {};\n\n        for (let i = 0; i < classNames.length; i++) {\n            const className = classNames[i];\n            const rule = classRules![className];\n\n            let resultOfRule: any;\n\n            if (typeof rule === 'string') {\n                resultOfRule = this.expressionService.evaluate(rule, params);\n            } else if (typeof rule === 'function') {\n                resultOfRule = rule(params);\n            }\n\n            // in case className = 'my-class1 my-class2', we need to split into individual class names\n            className.split(' ').forEach(singleClass => {\n                if (singleClass == null || singleClass.trim() == '') { return; }\n                resultOfRule ? classesToApply[singleClass] = true : classesToRemove[singleClass] = true;\n            });\n        }\n\n        // we remove all classes first, then add all classes second,\n        // in case a class appears in more than one rule, this means it will be added\n        // if appears in at least one truthy rule\n        if (onNotApplicableClass) {\n            Object.keys(classesToRemove).forEach(onNotApplicableClass);\n        }\n        Object.keys(classesToApply).forEach(onApplicableClass);\n    }\n\n    public getStaticCellClasses(colDef: ColDef, params: CellClassParams): string[] {\n        const { cellClass } = colDef;\n\n        if (!cellClass) { return []; }\n\n        let classOrClasses: string | string[] | null | undefined;\n\n        if (typeof cellClass === 'function') {\n            const cellClassFunc = cellClass;\n            classOrClasses = cellClassFunc(params);\n        } else {\n            classOrClasses = cellClass;\n        }\n\n        if (typeof classOrClasses === 'string') {\n            classOrClasses = [classOrClasses];\n        }\n\n        return classOrClasses || [];\n    }\n\n    private processStaticCellClasses(\n        colDef: ColDef,\n        params: CellClassParams,\n        onApplicableClass: (className: string) => void\n    ) {\n        const classOrClasses = this.getStaticCellClasses(colDef, params);\n\n        classOrClasses.forEach((cssClassItem: string) => {\n            onApplicableClass(cssClassItem);\n        });\n    }\n\n}\n"]}